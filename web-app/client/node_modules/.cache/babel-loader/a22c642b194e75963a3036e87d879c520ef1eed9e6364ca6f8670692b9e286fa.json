{"ast":null,"code":"/*\nCopyright (c) NAVER Corp.\nname: @egjs/infinitegrid\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-infinitegrid\nversion: 4.12.0\n*/\nimport Component, { ComponentEvent } from '@egjs/component';\nimport Grid, { GRID_PROPERTY_TYPES, GridItem, MOUNT_STATE, UPDATE_STATE, PROPERTY_TYPE, GetterSetter, DEFAULT_GRID_OPTIONS, getUpdatedItems, ContainerManager, ItemRenderer, MasonryGrid, JustifiedGrid, FrameGrid, PackingGrid } from '@egjs/grid';\nimport { withClassMethods, findTarget } from '@cfcs/core';\nimport { diff } from '@egjs/list-differ';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar ua = typeof window !== \"undefined\" ? window.navigator.userAgent : \"\";\nvar IS_IOS = /iPhone|iPad/.test(ua);\nvar CONTAINER_CLASS_NAME = \"infinitegrid-container\";\nvar IGNORE_PROPERITES_MAP = {\n  renderOnPropertyChange: true,\n  useFit: true,\n  autoResize: true\n};\nvar INFINITEGRID_PROPERTY_TYPES = __assign({}, GRID_PROPERTY_TYPES);\nvar DIRECTION = {\n  START: \"start\",\n  END: \"end\",\n  NONE: \"\"\n};\nvar INFINITEGRID_EVENTS = {\n  CHANGE_SCROLL: \"changeScroll\",\n  REQUEST_APPEND: \"requestAppend\",\n  REQUEST_PREPEND: \"requestPrepend\",\n  RENDER_COMPLETE: \"renderComplete\",\n  CONTENT_ERROR: \"contentError\"\n};\nvar ITEM_INFO_PROPERTIES = {\n  type: true,\n  groupKey: true,\n  key: true,\n  element: true,\n  html: true,\n  data: true,\n  inserted: true,\n  attributes: true\n};\nvar INFINITEGRID_METHODS = [\"insertByGroupIndex\", \"updateItems\", \"getItems\", \"getVisibleItems\", \"getGroups\", \"getVisibleGroups\", \"renderItems\", \"getContainerElement\", \"getScrollContainerElement\", \"getWrapperElement\", \"setStatus\", \"getStatus\", \"removePlaceholders\", \"prependPlaceholders\", \"appendPlaceholders\", \"getStartCursor\", \"getEndCursor\", \"setCursors\"];\nvar GROUP_TYPE;\n(function (GROUP_TYPE) {\n  GROUP_TYPE[GROUP_TYPE[\"NORMAL\"] = 0] = \"NORMAL\";\n  GROUP_TYPE[GROUP_TYPE[\"VIRTUAL\"] = 1] = \"VIRTUAL\";\n  GROUP_TYPE[GROUP_TYPE[\"LOADING\"] = 2] = \"LOADING\";\n})(GROUP_TYPE || (GROUP_TYPE = {}));\nvar ITEM_TYPE;\n(function (ITEM_TYPE) {\n  ITEM_TYPE[ITEM_TYPE[\"NORMAL\"] = 0] = \"NORMAL\";\n  ITEM_TYPE[ITEM_TYPE[\"VIRTUAL\"] = 1] = \"VIRTUAL\";\n  ITEM_TYPE[ITEM_TYPE[\"LOADING\"] = 2] = \"LOADING\";\n})(ITEM_TYPE || (ITEM_TYPE = {}));\nvar STATUS_TYPE;\n(function (STATUS_TYPE) {\n  // does not remove anything.\n  STATUS_TYPE[STATUS_TYPE[\"NOT_REMOVE\"] = 0] = \"NOT_REMOVE\";\n  // Minimize information on invisible items\n  STATUS_TYPE[STATUS_TYPE[\"MINIMIZE_INVISIBLE_ITEMS\"] = 1] = \"MINIMIZE_INVISIBLE_ITEMS\";\n  // Minimize information on invisible groups\n  STATUS_TYPE[STATUS_TYPE[\"MINIMIZE_INVISIBLE_GROUPS\"] = 2] = \"MINIMIZE_INVISIBLE_GROUPS\";\n  // remove invisible groups\n  STATUS_TYPE[STATUS_TYPE[\"REMOVE_INVISIBLE_GROUPS\"] = 3] = \"REMOVE_INVISIBLE_GROUPS\";\n})(STATUS_TYPE || (STATUS_TYPE = {}));\nvar INVISIBLE_POS = -9999;\n\n/**\n * @extends Grid.GridItem\n */\nvar InfiniteGridItem = /*#__PURE__*/function (_super) {\n  __extends(InfiniteGridItem, _super);\n  function InfiniteGridItem(horizontal, itemStatus) {\n    var _this = _super.call(this, horizontal, __assign({\n      html: \"\",\n      type: ITEM_TYPE.NORMAL,\n      cssRect: {\n        top: INVISIBLE_POS,\n        left: INVISIBLE_POS\n      }\n    }, itemStatus)) || this;\n    if (_this.type === ITEM_TYPE.VIRTUAL) {\n      if (_this.rect.width || _this.rect.height) {\n        _this.mountState = MOUNT_STATE.UNMOUNTED;\n      }\n      var orgRect = _this.orgRect;\n      var rect = _this.rect;\n      var cssRect = _this.cssRect;\n      if (cssRect.width) {\n        rect.width = cssRect.width;\n      } else if (orgRect.width) {\n        rect.width = orgRect.width;\n      }\n      if (cssRect.height) {\n        rect.height = cssRect.height;\n      } else if (orgRect.height) {\n        rect.height = orgRect.height;\n      }\n    }\n    return _this;\n  }\n  var __proto = InfiniteGridItem.prototype;\n  __proto.getVirtualStatus = function () {\n    return {\n      type: ITEM_TYPE.VIRTUAL,\n      groupKey: this.groupKey,\n      key: this.key,\n      orgRect: this.orgRect,\n      rect: this.rect,\n      cssRect: this.cssRect,\n      attributes: this.attributes\n    };\n  };\n  __proto.getMinimizedStatus = function () {\n    var status = __assign(__assign({}, _super.prototype.getMinimizedStatus.call(this)), {\n      type: ITEM_TYPE.NORMAL,\n      groupKey: this.groupKey\n    });\n    if (this.html) {\n      status.html = this.html;\n    }\n    return status;\n  };\n  return InfiniteGridItem;\n}(GridItem);\nvar LOADING_GROUP_KEY = \"__INFINITEGRID__LOADING_GRID\";\nvar LOADING_ITEM_KEY = \"__INFINITEGRID__LOADING_ITEM\";\nvar LoadingGrid = /*#__PURE__*/function (_super) {\n  __extends(LoadingGrid, _super);\n  function LoadingGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.type = \"\";\n    _this.isWaitEnd = false;\n    _this.initialDisplay = null;\n    return _this;\n  }\n  var __proto = LoadingGrid.prototype;\n  __proto.getLoadingItem = function () {\n    return this.items[0] || null;\n  };\n  __proto.startLoading = function () {\n    var element = this.items[0].element;\n    if (element) {\n      if (this.initialDisplay != null) {\n        this.initialDisplay = element.style.display || \"\";\n      } else if (this.initialDisplay) {\n        element.style.display = this.initialDisplay;\n      } else {\n        element.style.removeProperty(\"display\");\n      }\n    }\n  };\n  __proto.endLoading = function () {\n    if (this.type) {\n      var element = this.items[0].element;\n      if (element) {\n        element.style.display = \"none\";\n      }\n    }\n  };\n  __proto.setLoadingItem = function (item) {\n    if (item) {\n      var loadingItem = this.getLoadingItem();\n      if (!loadingItem) {\n        this.items = [new InfiniteGridItem(this.options.horizontal, __assign(__assign({}, item), {\n          type: ITEM_TYPE.LOADING,\n          key: LOADING_ITEM_KEY\n        }))];\n      } else {\n        for (var name in item) {\n          loadingItem[name] = item[name];\n        }\n      }\n    } else {\n      this.items = [];\n    }\n  };\n  __proto.applyGrid = function (items, direction, outline) {\n    if (!items.length) {\n      return {\n        start: outline,\n        end: outline\n      };\n    }\n    var nextOutline = outline.length ? __spreadArray([], outline, true) : [0];\n    var item = items[0];\n    var offset = item.contentSize + this.getContentGap();\n    item.cssInlinePos = this.getContainerInlineSize() / 2 - item.inlineSize / 2;\n    if (direction === \"end\") {\n      var maxPos = Math.max.apply(Math, nextOutline);\n      item.cssContentPos = maxPos;\n      return {\n        start: nextOutline,\n        end: nextOutline.map(function (pos) {\n          return pos + offset;\n        })\n      };\n    } else {\n      var minPos = Math.min.apply(Math, nextOutline);\n      item.cssContentPos = minPos - offset;\n      return {\n        start: nextOutline.map(function (pos) {\n          return pos - offset;\n        }),\n        end: nextOutline\n      };\n    }\n  };\n  return LoadingGrid;\n}(Grid);\nfunction isWindow(el) {\n  return el === window;\n}\nfunction isNumber(val) {\n  return typeof val === \"number\";\n}\nfunction isString(val) {\n  return typeof val === \"string\";\n}\nfunction isObject(val) {\n  return typeof val === \"object\";\n}\nfunction flat(arr) {\n  return arr.reduce(function (prev, cur) {\n    return __spreadArray(__spreadArray([], prev, true), cur, true);\n  }, []);\n}\nfunction splitOptions(options) {\n  var gridOptions = options.gridOptions,\n    otherOptions = __rest(options, [\"gridOptions\"]);\n  return __assign(__assign({}, splitGridOptions(gridOptions)), otherOptions);\n}\nfunction splitGridOptions(options) {\n  var nextOptions = {};\n  var gridOptions = {};\n  var defaultOptions = Grid.defaultOptions;\n  for (var name in options) {\n    var value = options[name];\n    if (!(name in IGNORE_PROPERITES_MAP)) {\n      gridOptions[name] = value;\n    }\n    if (name in defaultOptions) {\n      nextOptions[name] = value;\n    }\n  }\n  return __assign(__assign({}, nextOptions), {\n    gridOptions: gridOptions\n  });\n}\nfunction categorize(items) {\n  var groups = [];\n  var groupKeys = {};\n  var registeredGroupKeys = {};\n  items.filter(function (item) {\n    return item.groupKey != null;\n  }).forEach(function (_a) {\n    var groupKey = _a.groupKey;\n    registeredGroupKeys[groupKey] = true;\n  });\n  var generatedGroupKey;\n  var isContinuousGroupKey = false;\n  items.forEach(function (item, i) {\n    if (item.groupKey != null) {\n      isContinuousGroupKey = false;\n    } else if (!item.inserted && items[i - 1]) {\n      // In case of framework, inserted is false.\n      // If groupKey is not set, the group key of the previous item is followed.\n      item.groupKey = items[i - 1].groupKey;\n      isContinuousGroupKey = false;\n    } else {\n      if (!isContinuousGroupKey) {\n        generatedGroupKey = makeKey(registeredGroupKeys);\n        isContinuousGroupKey = true;\n        registeredGroupKeys[generatedGroupKey] = true;\n      }\n      item.groupKey = generatedGroupKey;\n    }\n    var groupKey = item.groupKey;\n    var group = groupKeys[groupKey];\n    if (!group) {\n      group = {\n        groupKey: groupKey,\n        items: []\n      };\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n    group.items.push(item);\n  });\n  return groups;\n}\nfunction getNextCursors(prevKeys, nextKeys, prevStartCursor, prevEndCursor) {\n  var result = diff(prevKeys, nextKeys, function (key) {\n    return key;\n  });\n  var nextStartCursor = -1;\n  var nextEndCursor = -1;\n  // sync cursors\n  result.maintained.forEach(function (_a) {\n    var prevIndex = _a[0],\n      nextIndex = _a[1];\n    if (prevStartCursor <= prevIndex && prevIndex <= prevEndCursor) {\n      if (nextStartCursor === -1) {\n        nextStartCursor = nextIndex;\n        nextEndCursor = nextIndex;\n      } else {\n        nextStartCursor = Math.min(nextStartCursor, nextIndex);\n        nextEndCursor = Math.max(nextEndCursor, nextIndex);\n      }\n    }\n  });\n  return {\n    startCursor: nextStartCursor,\n    endCursor: nextEndCursor\n  };\n}\nfunction splitVirtualGroups(groups, direction, nextGroups) {\n  var virtualGroups = [];\n  if (direction === \"start\") {\n    var index = findIndex(groups, function (group) {\n      return group.type === GROUP_TYPE.NORMAL;\n    });\n    if (index === -1) {\n      return [];\n    }\n    // Get the virtual group maintained in the group from the next group.\n    var endMaintainedIndex = findIndex(groups, function (group) {\n      return findIndex(nextGroups, function (nextGroup) {\n        return nextGroup.groupKey === group.groupKey;\n      }) >= 0;\n    });\n    var endIndex = endMaintainedIndex >= 0 ? Math.min(index, endMaintainedIndex) : index;\n    virtualGroups = groups.slice(0, endIndex);\n  } else {\n    var index = findLastIndex(groups, function (group) {\n      return group.type === GROUP_TYPE.NORMAL;\n    });\n    if (index === -1) {\n      return [];\n    }\n    var startMaintainedIndex = findLastIndex(groups, function (group) {\n      return findIndex(nextGroups, function (nextGroup) {\n        return nextGroup.groupKey === group.groupKey;\n      }) >= 0;\n    });\n    var startIndex = startMaintainedIndex >= 0 ? Math.max(index, startMaintainedIndex) : index;\n    virtualGroups = groups.slice(startIndex + 1);\n  }\n  return virtualGroups;\n}\nfunction getFirstRenderingItems(nextItems, horizontal) {\n  var groups = categorize(nextItems);\n  if (!groups[0]) {\n    return [];\n  }\n  return groups[0].items.map(function (item) {\n    return new InfiniteGridItem(horizontal, __assign({}, item));\n  });\n}\nfunction getRenderingItemsByStatus(groupManagerStatus, nextItems, usePlaceholder, horizontal) {\n  var prevGroups = groupManagerStatus.groups;\n  var groups = categorize(nextItems);\n  var startVirtualGroups = splitVirtualGroups(prevGroups, \"start\", groups);\n  var endVirtualGroups = splitVirtualGroups(prevGroups, \"end\", groups);\n  var nextGroups = __spreadArray(__spreadArray(__spreadArray([], startVirtualGroups, true), groups, true), endVirtualGroups, true);\n  var _a = getNextCursors(prevGroups.map(function (group) {\n      return group.groupKey;\n    }), nextGroups.map(function (group) {\n      return group.groupKey;\n    }), groupManagerStatus.cursors[0], groupManagerStatus.cursors[1]),\n    startCursor = _a.startCursor,\n    endCursor = _a.endCursor;\n  var nextVisibleItems = flat(nextGroups.slice(startCursor, endCursor + 1).map(function (group) {\n    return group.items.map(function (item) {\n      return new InfiniteGridItem(horizontal, __assign({}, item));\n    });\n  }));\n  if (!usePlaceholder) {\n    nextVisibleItems = nextVisibleItems.filter(function (item) {\n      return item.type !== ITEM_TYPE.VIRTUAL;\n    });\n  }\n  return nextVisibleItems;\n}\nfunction mountRenderingItems(items, options) {\n  var grid = options.grid,\n    usePlaceholder = options.usePlaceholder,\n    useLoading = options.useLoading,\n    useFirstRender = options.useFirstRender,\n    status = options.status;\n  if (!grid) {\n    return;\n  }\n  if (usePlaceholder) {\n    grid.setPlaceholder({});\n  }\n  if (useLoading) {\n    grid.setLoading({});\n  }\n  if (status) {\n    grid.setStatus(status, true);\n  }\n  grid.syncItems(items);\n  if (useFirstRender && !status && grid.getGroups().length) {\n    grid.setCursors(0, 0, true);\n  }\n}\nfunction getRenderingItems(items, options) {\n  var status = options.status,\n    usePlaceholder = options.usePlaceholder,\n    useLoading = options.useLoading,\n    horizontal = options.horizontal,\n    useFirstRender = options.useFirstRender,\n    grid = options.grid;\n  var visibleItems = [];\n  if (grid) {\n    grid.setPlaceholder(usePlaceholder ? {} : null);\n    grid.setLoading(useLoading ? {} : null);\n    grid.syncItems(items);\n    visibleItems = grid.getRenderingItems();\n  } else if (status) {\n    visibleItems = getRenderingItemsByStatus(status.groupManager, items, !!usePlaceholder, !!horizontal);\n  } else if (useFirstRender) {\n    visibleItems = getFirstRenderingItems(items, !!horizontal);\n  }\n  return visibleItems;\n}\n/* Class Decorator */\nfunction InfiniteGridGetterSetter(component) {\n  var prototype = component.prototype,\n    propertyTypes = component.propertyTypes;\n  var _loop_1 = function (name) {\n    var attributes = {\n      enumerable: true,\n      configurable: true,\n      get: function () {\n        var options = this.groupManager.options;\n        if (name in options) {\n          return options[name];\n        } else {\n          return options.gridOptions[name];\n        }\n      },\n      set: function (value) {\n        var _a;\n        var prevValue = this.groupManager[name];\n        if (prevValue === value) {\n          return;\n        }\n        this.groupManager.gridOptions = (_a = {}, _a[name] = value, _a);\n      }\n    };\n    Object.defineProperty(prototype, name, attributes);\n  };\n  for (var name in propertyTypes) {\n    _loop_1(name);\n  }\n}\nfunction makeKey(registeredKeys, prefix) {\n  if (prefix === void 0) {\n    prefix = \"\";\n  }\n  var index = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    var key = \"infinitegrid_\".concat(prefix).concat(index++);\n    if (!(key in registeredKeys)) {\n      return key;\n    }\n  }\n}\nfunction convertHTMLtoElement(html) {\n  var dummy = document.createElement(\"div\");\n  dummy.innerHTML = html;\n  return toArray(dummy.children);\n}\nfunction convertInsertedItems(items, groupKey) {\n  var insertedItems;\n  if (isString(items)) {\n    insertedItems = convertHTMLtoElement(items);\n  } else {\n    insertedItems = items;\n  }\n  return insertedItems.map(function (item) {\n    var element;\n    var html = \"\";\n    var key;\n    if (isString(item)) {\n      html = item;\n    } else if (\"parentNode\" in item) {\n      element = item;\n      html = item.outerHTML;\n    } else {\n      // inserted is true when adding via a method.\n      return __assign({\n        groupKey: groupKey,\n        inserted: true\n      }, item);\n    }\n    // inserted is true when adding via a method.\n    return {\n      key: key,\n      groupKey: groupKey,\n      html: html,\n      element: element,\n      inserted: true\n    };\n  });\n}\nfunction toArray(nodes) {\n  var array = [];\n  if (nodes) {\n    var length = nodes.length;\n    for (var i = 0; i < length; i++) {\n      array.push(nodes[i]);\n    }\n  }\n  return array;\n}\nfunction findIndex(arr, callback) {\n  var length = arr.length;\n  for (var i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction findLastIndex(arr, callback) {\n  var length = arr.length;\n  for (var i = length - 1; i >= 0; --i) {\n    if (callback(arr[i], i)) {\n      return i;\n    }\n  }\n  return -1;\n}\nfunction getItemInfo(info) {\n  var nextInfo = {};\n  for (var name in info) {\n    if (name in ITEM_INFO_PROPERTIES) {\n      nextInfo[name] = info[name];\n    }\n  }\n  return nextInfo;\n}\nfunction setPlaceholder(item, info) {\n  for (var name in info) {\n    var value = info[name];\n    if (isObject(value)) {\n      item[name] = __assign(__assign({}, item[name]), value);\n    } else {\n      item[name] = info[name];\n    }\n  }\n}\nfunction isFlatOutline(start, end) {\n  return start.length === end.length && start.every(function (pos, i) {\n    return end[i] === pos;\n  });\n}\nfunction range(length) {\n  var arr = [];\n  for (var i = 0; i < length; ++i) {\n    arr.push(i);\n  }\n  return arr;\n}\nfunction flatGroups(groups) {\n  return flat(groups.map(function (_a) {\n    var grid = _a.grid;\n    return grid.getItems();\n  }));\n}\nfunction filterVirtuals(items, includePlaceholders) {\n  if (includePlaceholders) {\n    return __spreadArray([], items, true);\n  } else {\n    return items.filter(function (item) {\n      return item.type !== ITEM_TYPE.VIRTUAL;\n    });\n  }\n}\n/**\n * Decorator that makes the method of InfiniteGrid available in the framework.\n * @ko 프레임워크에서 InfiniteGrid의 메소드를 사용할 수 있게 하는 데코레이터.\n * @private\n * @example\n * ```js\n * import { withInfiniteGridMethods } from \"@egjs/infinitegrid\";\n *\n * class Grid extends React.Component<Partial<InfiniteGridProps & InfiniteGridOptions>> {\n *   &#64;withInfiniteGridMethods\n *   private grid: NativeGrid;\n * }\n * ```\n */\nvar withInfiniteGridMethods = withClassMethods(INFINITEGRID_METHODS);\nvar GroupManager = /*#__PURE__*/function (_super) {\n  __extends(GroupManager, _super);\n  function GroupManager(container, options) {\n    var _this = _super.call(this, container, splitOptions(options)) || this;\n    _this.groupItems = [];\n    _this.groups = [];\n    _this.itemKeys = {};\n    _this.groupKeys = {};\n    _this.startCursor = 0;\n    _this.endCursor = 0;\n    _this._placeholder = null;\n    _this._loadingGrid = new LoadingGrid(container, {\n      externalContainerManager: _this.containerManager,\n      useFit: false,\n      autoResize: false,\n      renderOnPropertyChange: false,\n      gap: _this.gap\n    });\n    _this._mainGrid = _this._makeGrid();\n    return _this;\n  }\n  var __proto = GroupManager.prototype;\n  Object.defineProperty(__proto, \"gridOptions\", {\n    set: function (options) {\n      var _a = splitGridOptions(options),\n        gridOptions = _a.gridOptions,\n        otherOptions = __rest(_a, [\"gridOptions\"]);\n      var shouldRender = this._checkShouldRender(options);\n      this.options.gridOptions = __assign(__assign({}, this.options.gridOptions), gridOptions);\n      __spreadArray([this._mainGrid], this.groups.map(function (_a) {\n        var grid = _a.grid;\n        return grid;\n      }), true).forEach(function (grid) {\n        for (var name in options) {\n          grid[name] = options[name];\n        }\n      });\n      for (var name in otherOptions) {\n        this[name] = otherOptions[name];\n      }\n      this._loadingGrid.gap = this.gap;\n      if (shouldRender) {\n        this.scheduleRender();\n      }\n    },\n    enumerable: false,\n    configurable: true\n  });\n  __proto.getItemByKey = function (key) {\n    return this.itemKeys[key] || null;\n  };\n  __proto.getGroupItems = function (includePlaceholders) {\n    return filterVirtuals(this.groupItems, includePlaceholders);\n  };\n  __proto.getVisibleItems = function (includePlaceholders) {\n    return filterVirtuals(this.items, includePlaceholders);\n  };\n  __proto.getRenderingItems = function () {\n    if (this.hasPlaceholder()) {\n      return this.items;\n    } else {\n      return this.items.filter(function (item) {\n        return item.type !== ITEM_TYPE.VIRTUAL;\n      });\n    }\n  };\n  __proto.getGroups = function (includePlaceholders) {\n    return filterVirtuals(this.groups, includePlaceholders);\n  };\n  __proto.hasVisibleVirtualGroups = function () {\n    return this.getVisibleGroups(true).some(function (group) {\n      return group.type === GROUP_TYPE.VIRTUAL;\n    });\n  };\n  __proto.hasPlaceholder = function () {\n    return !!this._placeholder;\n  };\n  __proto.hasLoadingItem = function () {\n    return !!this._getLoadingItem();\n  };\n  __proto.updateItems = function (items, options) {\n    if (items === void 0) {\n      items = this.groupItems;\n    }\n    return _super.prototype.updateItems.call(this, items, options);\n  };\n  __proto.setPlaceholder = function (placeholder) {\n    this._placeholder = placeholder;\n    this._updatePlaceholder();\n  };\n  __proto.getLoadingType = function () {\n    return this._loadingGrid.type;\n  };\n  __proto.startLoading = function (type) {\n    this._loadingGrid.type = type;\n    this.items = this._getRenderingItems();\n    return true;\n  };\n  __proto.waitEndLoading = function () {\n    if (this._loadingGrid.type) {\n      this._loadingGrid.isWaitEnd = true;\n      return true;\n    }\n    return false;\n  };\n  __proto.endLoading = function () {\n    if (this._loadingGrid.isWaitEnd) {\n      var prevType = this._loadingGrid.type;\n      this._loadingGrid.type = \"\";\n      this._loadingGrid.endLoading();\n      this.items = this._getRenderingItems();\n      return !!prevType;\n    }\n    return false;\n  };\n  __proto.setLoading = function (loading) {\n    this._loadingGrid.setLoadingItem(loading);\n    this.items = this._getRenderingItems();\n  };\n  __proto.getVisibleGroups = function (includePlaceholders) {\n    var groups = this.groups.slice(this.startCursor, this.endCursor + 1);\n    return filterVirtuals(groups, includePlaceholders);\n  };\n  __proto.getComputedOutlineLength = function (items) {\n    if (items === void 0) {\n      items = this.items;\n    }\n    return this._mainGrid.getComputedOutlineLength(items);\n  };\n  __proto.getComputedOutlineSize = function (items) {\n    if (items === void 0) {\n      items = this.items;\n    }\n    return this._mainGrid.getComputedOutlineSize(items);\n  };\n  __proto.applyGrid = function (items, direction, outline) {\n    var _this = this;\n    var renderingGroups = this.groups.slice();\n    if (!renderingGroups.length) {\n      return {\n        start: [],\n        end: []\n      };\n    }\n    var loadingGrid = this._loadingGrid;\n    if (loadingGrid.getLoadingItem()) {\n      if (loadingGrid.type === \"start\") {\n        renderingGroups.unshift(this._getLoadingGroup());\n      } else if (loadingGrid.type === \"end\") {\n        renderingGroups.push(this._getLoadingGroup());\n      }\n    }\n    var groups = renderingGroups.slice();\n    var nextOutline = outline;\n    if (direction === \"start\") {\n      groups.reverse();\n    }\n    var appliedItemChecker = this.options.appliedItemChecker;\n    var groupItems = this.groupItems;\n    var outlineLength = this.getComputedOutlineLength(groupItems);\n    var outlineSize = this.getComputedOutlineSize(groupItems);\n    var itemRenderer = this.itemRenderer;\n    var passedItems = [];\n    groups.forEach(function (group) {\n      var _a, _b;\n      var grid = group.grid;\n      var gridItems = grid.getItems();\n      var isVirtual = group.type === GROUP_TYPE.VIRTUAL && !gridItems[0];\n      passedItems = direction === \"end\" ? __spreadArray(__spreadArray([], passedItems, true), gridItems, true) : __spreadArray(__spreadArray([], gridItems, true), passedItems, true);\n      grid.outlineLength = outlineLength;\n      grid.outlineSize = outlineSize;\n      var appliedItems = passedItems.filter(function (item) {\n        if (item.mountState === MOUNT_STATE.UNCHECKED || !item.rect.width) {\n          itemRenderer.updateItem(item, true);\n        }\n        return item.orgRect.width && item.rect.width || appliedItemChecker(item, grid);\n      });\n      var gridOutlines;\n      if (isVirtual) {\n        gridOutlines = _this._applyVirtualGrid(grid, direction, nextOutline);\n      } else if (appliedItems.length) {\n        gridOutlines = grid.applyGrid(appliedItems, direction, nextOutline);\n      } else {\n        gridOutlines = {\n          start: __spreadArray([], nextOutline, true),\n          end: __spreadArray([], nextOutline, true)\n        };\n      }\n      grid.setOutlines(gridOutlines);\n      nextOutline = gridOutlines.passed || gridOutlines[direction];\n      passedItems = (_b = (_a = gridOutlines.passedItems) === null || _a === void 0 ? void 0 : _a.map(function (index) {\n        return passedItems[index];\n      })) !== null && _b !== void 0 ? _b : [];\n    });\n    return {\n      start: renderingGroups[0].grid.getOutlines().start,\n      end: renderingGroups[renderingGroups.length - 1].grid.getOutlines().end\n    };\n  };\n  __proto.syncItems = function (nextItemInfos) {\n    var _this = this;\n    var prevItemKeys = this.itemKeys;\n    this.itemKeys = {};\n    var nextItems = this._syncItemInfos(nextItemInfos.map(function (info) {\n      return getItemInfo(info);\n    }), prevItemKeys);\n    var prevGroupKeys = this.groupKeys;\n    var nextManagerGroups = categorize(nextItems);\n    var startVirtualGroups = this._splitVirtualGroups(\"start\", nextManagerGroups);\n    var endVirtualGroups = this._splitVirtualGroups(\"end\", nextManagerGroups);\n    nextManagerGroups = __spreadArray(__spreadArray(__spreadArray([], startVirtualGroups, true), this._mergeVirtualGroups(nextManagerGroups), true), endVirtualGroups, true);\n    var nextGroups = nextManagerGroups.map(function (_a) {\n      var _b, _c;\n      var groupKey = _a.groupKey,\n        items = _a.items;\n      var isVirtual = !items[0] || items[0].type === ITEM_TYPE.VIRTUAL;\n      var grid = (_c = (_b = prevGroupKeys[groupKey]) === null || _b === void 0 ? void 0 : _b.grid) !== null && _c !== void 0 ? _c : _this._makeGrid();\n      var gridItems = isVirtual ? items : items.filter(function (_a) {\n        var type = _a.type;\n        return type === ITEM_TYPE.NORMAL;\n      });\n      grid.setItems(gridItems);\n      return {\n        type: isVirtual ? GROUP_TYPE.VIRTUAL : GROUP_TYPE.NORMAL,\n        groupKey: groupKey,\n        grid: grid,\n        items: gridItems,\n        renderItems: items\n      };\n    });\n    this._registerGroups(nextGroups);\n  };\n  __proto.renderItems = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (options.useResize) {\n      this.groupItems.forEach(function (item) {\n        item.updateState = UPDATE_STATE.NEED_UPDATE;\n      });\n      var loadingItem = this._getLoadingItem();\n      if (loadingItem) {\n        loadingItem.updateState = UPDATE_STATE.NEED_UPDATE;\n      }\n    }\n    return _super.prototype.renderItems.call(this, options);\n  };\n  __proto.setCursors = function (startCursor, endCursor) {\n    this.startCursor = startCursor;\n    this.endCursor = endCursor;\n    this.items = this._getRenderingItems();\n  };\n  __proto.getStartCursor = function () {\n    return this.startCursor;\n  };\n  __proto.getEndCursor = function () {\n    return this.endCursor;\n  };\n  __proto.getGroupStatus = function (type, includePlaceholders) {\n    var orgStartCursor = this.startCursor;\n    var orgEndCursor = this.endCursor;\n    var orgGroups = this.groups;\n    var startGroup = orgGroups[orgStartCursor];\n    var endGroup = orgGroups[orgEndCursor];\n    var startCursor = orgStartCursor;\n    var endCursor = orgEndCursor;\n    var isMinimizeItems = type === STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS;\n    var isMinimizeGroups = type === STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS;\n    var groups;\n    if (type === STATUS_TYPE.REMOVE_INVISIBLE_GROUPS) {\n      groups = this.getVisibleGroups(includePlaceholders);\n      endCursor = groups.length - 1;\n      startCursor = 0;\n    } else {\n      groups = this.getGroups(includePlaceholders);\n      if (!includePlaceholders) {\n        startCursor = -1;\n        endCursor = -1;\n        for (var orgIndex = orgStartCursor; orgIndex <= orgEndCursor; ++orgIndex) {\n          var orgGroup = orgGroups[orgIndex];\n          if (orgGroup && orgGroup.type !== GROUP_TYPE.VIRTUAL) {\n            startCursor = groups.indexOf(orgGroup);\n            break;\n          }\n        }\n        for (var orgIndex = orgEndCursor; orgIndex >= orgStartCursor; --orgIndex) {\n          var orgGroup = orgGroups[orgIndex];\n          if (orgGroup && orgGroup.type !== GROUP_TYPE.VIRTUAL) {\n            endCursor = groups.lastIndexOf(orgGroup);\n            break;\n          }\n        }\n      }\n    }\n    var groupStatus = groups.map(function (_a, i) {\n      var grid = _a.grid,\n        groupKey = _a.groupKey;\n      var isOutsideCursor = i < startCursor || endCursor < i;\n      var isVirtualItems = isMinimizeItems && isOutsideCursor;\n      var isVirtualGroup = isMinimizeGroups && isOutsideCursor;\n      var gridItems = grid.getItems();\n      var items = isVirtualGroup ? [] : gridItems.map(function (item) {\n        return isVirtualItems ? item.getVirtualStatus() : item.getMinimizedStatus();\n      });\n      return {\n        type: isVirtualGroup || isVirtualItems ? GROUP_TYPE.VIRTUAL : GROUP_TYPE.NORMAL,\n        groupKey: groupKey,\n        outlines: grid.getOutlines(),\n        items: items\n      };\n    });\n    var totalItems = this.getGroupItems();\n    var itemStartCursor = totalItems.indexOf(startGroup === null || startGroup === void 0 ? void 0 : startGroup.items[0]);\n    var itemEndCursor = totalItems.indexOf(endGroup === null || endGroup === void 0 ? void 0 : endGroup.items.slice().reverse()[0]);\n    return {\n      cursors: [startCursor, endCursor],\n      orgCursors: [orgStartCursor, orgEndCursor],\n      itemCursors: [itemStartCursor, itemEndCursor],\n      startGroupKey: startGroup === null || startGroup === void 0 ? void 0 : startGroup.groupKey,\n      endGroupKey: endGroup === null || endGroup === void 0 ? void 0 : endGroup.groupKey,\n      groups: groupStatus,\n      outlines: this.outlines\n    };\n  };\n  __proto.fitOutlines = function (useFit) {\n    if (useFit === void 0) {\n      useFit = this.useFit;\n    }\n    var groups = this.groups;\n    if (!groups[0]) {\n      return;\n    }\n    var outlines = this.outlines;\n    var startOutline = outlines.start;\n    var outlineOffset = startOutline.length ? Math.min.apply(Math, startOutline) : 0;\n    // If the outline is less than 0, a fit occurs forcibly.\n    if (!useFit && outlineOffset > 0) {\n      return;\n    }\n    groups.forEach(function (_a) {\n      var grid = _a.grid;\n      var _b = grid.getOutlines(),\n        start = _b.start,\n        end = _b.end;\n      grid.setOutlines({\n        start: start.map(function (point) {\n          return point - outlineOffset;\n        }),\n        end: end.map(function (point) {\n          return point - outlineOffset;\n        })\n      });\n    });\n    this.groupItems.forEach(function (item) {\n      var contentPos = item.cssContentPos;\n      if (!isNumber(contentPos)) {\n        return;\n      }\n      item.cssContentPos = contentPos - outlineOffset;\n    });\n  };\n  __proto.setGroupStatus = function (status) {\n    var _this = this;\n    this.itemKeys = {};\n    this.groupItems = [];\n    this.items = [];\n    var prevGroupKeys = this.groupKeys;\n    var nextGroups = status.groups.map(function (_a) {\n      var _b, _c;\n      var type = _a.type,\n        groupKey = _a.groupKey,\n        items = _a.items,\n        outlines = _a.outlines;\n      var nextItems = _this._syncItemInfos(items);\n      var grid = (_c = (_b = prevGroupKeys[groupKey]) === null || _b === void 0 ? void 0 : _b.grid) !== null && _c !== void 0 ? _c : _this._makeGrid();\n      grid.setOutlines(outlines);\n      grid.setItems(nextItems);\n      return {\n        type: type,\n        groupKey: groupKey,\n        grid: grid,\n        items: nextItems,\n        renderItems: nextItems\n      };\n    });\n    this.setOutlines(status.outlines);\n    this._registerGroups(nextGroups);\n    this._updatePlaceholder();\n    this.setCursors(status.cursors[0], status.cursors[1]);\n  };\n  __proto.appendPlaceholders = function (items, groupKey) {\n    return this.insertPlaceholders(\"end\", items, groupKey);\n  };\n  __proto.prependPlaceholders = function (items, groupKey) {\n    return this.insertPlaceholders(\"start\", items, groupKey);\n  };\n  __proto.removePlaceholders = function (type) {\n    var groups = this.groups;\n    var length = groups.length;\n    if (type === \"start\") {\n      var index = findIndex(groups, function (group) {\n        return group.type === GROUP_TYPE.NORMAL;\n      });\n      groups.splice(0, index);\n    } else if (type === \"end\") {\n      var index = findLastIndex(groups, function (group) {\n        return group.type === GROUP_TYPE.NORMAL;\n      });\n      groups.splice(index + 1, length - index - 1);\n    } else {\n      var groupKey_1 = type.groupKey;\n      var index = findIndex(groups, function (group) {\n        return group.groupKey === groupKey_1;\n      });\n      if (index > -1) {\n        groups.splice(index, 1);\n      }\n    }\n    this.syncItems(flatGroups(this.getGroups()));\n  };\n  __proto.insertPlaceholders = function (direction, items, groupKey) {\n    var _a, _b;\n    if (groupKey === void 0) {\n      groupKey = makeKey(this.groupKeys, \"virtual_\");\n    }\n    var infos = [];\n    if (isNumber(items)) {\n      infos = range(items).map(function () {\n        return {\n          type: ITEM_TYPE.VIRTUAL,\n          groupKey: groupKey\n        };\n      });\n    } else if (Array.isArray(items)) {\n      infos = items.map(function (status) {\n        return __assign(__assign({\n          groupKey: groupKey\n        }, status), {\n          type: ITEM_TYPE.VIRTUAL\n        });\n      });\n    }\n    var grid = this._makeGrid();\n    var nextItems = this._syncItemInfos(infos, this.itemKeys);\n    this._updatePlaceholder(nextItems);\n    grid.setItems(nextItems);\n    var group = {\n      type: GROUP_TYPE.VIRTUAL,\n      groupKey: groupKey,\n      grid: grid,\n      items: nextItems,\n      renderItems: nextItems\n    };\n    this.groupKeys[groupKey] = group;\n    if (direction === \"end\") {\n      this.groups.push(group);\n      (_a = this.groupItems).push.apply(_a, nextItems);\n    } else {\n      this.groups.splice(0, 0, group);\n      (_b = this.groupItems).splice.apply(_b, __spreadArray([0, 0], nextItems, false));\n      if (this.startCursor > -1) {\n        ++this.startCursor;\n        ++this.endCursor;\n      }\n    }\n    return {\n      group: group,\n      items: nextItems\n    };\n  };\n  __proto.shouldRerenderItems = function () {\n    var isRerender = false;\n    this.getVisibleGroups().forEach(function (group) {\n      var items = group.items;\n      if (items.length === group.renderItems.length || items.every(function (item) {\n        return item.mountState === MOUNT_STATE.UNCHECKED;\n      })) {\n        return;\n      }\n      isRerender = true;\n      group.renderItems = __spreadArray([], items, true);\n    });\n    if (isRerender) {\n      this.items = this._getRenderingItems();\n    }\n    return isRerender;\n  };\n  // protected checkReady(options: RenderOptions = {}) {\n  //   const items = this.items;\n  //   const updated = items.filter((item) => item.element?.parentNode && item.updateState !== UPDATE_STATE.UPDATED);\n  //   const mounted = items.filter((item) => item.element?.parentNode && item.mountState !== MOUNT_STATE.MOUNTED);\n  //   if (updated.length && updated.every((item) => item.type != ITEM_TYPE.NORMAL)) {\n  //     this._updateItems(updated);\n  //     this.readyItems(mounted, updated, options);\n  //   } else {\n  //     super.checkReady(options);\n  //   }\n  // }\n  __proto._updateItems = function (items) {\n    this.itemRenderer.updateEqualSizeItems(items, this.groupItems);\n  };\n  __proto._getGroupItems = function () {\n    return flatGroups(this.getGroups(true));\n  };\n  __proto._getRenderingItems = function () {\n    var items = flat(this.getVisibleGroups(true).map(function (item) {\n      return item.renderItems;\n    }));\n    var loadingGrid = this._loadingGrid;\n    var loadingItem = loadingGrid.getLoadingItem();\n    if (loadingItem) {\n      if (loadingGrid.type === \"end\") {\n        items.push(loadingItem);\n      } else if (loadingGrid.type === \"start\") {\n        items.unshift(loadingItem);\n      }\n    }\n    return items;\n  };\n  __proto._checkShouldRender = function (options) {\n    var GridConstructor = this.options.gridConstructor;\n    var prevOptions = this.gridOptions;\n    var propertyTypes = GridConstructor.propertyTypes;\n    for (var name in prevOptions) {\n      if (!(name in options) && propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY) {\n        return true;\n      }\n    }\n    for (var name in options) {\n      if (prevOptions[name] !== options[name] && propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY) {\n        return true;\n      }\n    }\n    return false;\n  };\n  __proto._applyVirtualGrid = function (grid, direction, outline) {\n    var startOutline = outline.length ? __spreadArray([], outline, true) : [0];\n    var prevOutlines = grid.getOutlines();\n    var prevOutline = prevOutlines[direction === \"end\" ? \"start\" : \"end\"];\n    if (prevOutline.length !== startOutline.length || prevOutline.some(function (value, i) {\n      return value !== startOutline[i];\n    })) {\n      return {\n        start: __spreadArray([], startOutline, true),\n        end: __spreadArray([], startOutline, true)\n      };\n    }\n    return prevOutlines;\n  };\n  __proto._syncItemInfos = function (nextItemInfos, prevItemKeys) {\n    if (prevItemKeys === void 0) {\n      prevItemKeys = {};\n    }\n    var horizontal = this.options.horizontal;\n    var nextItemKeys = this.itemKeys;\n    nextItemInfos.filter(function (info) {\n      return info.key != null;\n    }).forEach(function (info) {\n      var key = info.key;\n      var prevItem = prevItemKeys[key];\n      if (!prevItem) {\n        nextItemKeys[key] = new InfiniteGridItem(horizontal, __assign({}, info));\n      } else if (prevItem.type === ITEM_TYPE.VIRTUAL && info.type !== ITEM_TYPE.VIRTUAL) {\n        nextItemKeys[key] = new InfiniteGridItem(horizontal, __assign({\n          orgRect: prevItem.orgRect,\n          rect: prevItem.rect\n        }, info));\n      } else {\n        if (info.data) {\n          prevItem.data = info.data;\n        }\n        if (info.groupKey != null) {\n          prevItem.groupKey = info.groupKey;\n        }\n        if (info.element) {\n          prevItem.element = info.element;\n        }\n        nextItemKeys[key] = prevItem;\n      }\n    });\n    var nextItems = nextItemInfos.map(function (info) {\n      var key = info.key;\n      if (info.key == null) {\n        key = makeKey(nextItemKeys, info.type === ITEM_TYPE.VIRTUAL ? \"virtual_\" : \"\");\n      }\n      var item = nextItemKeys[key];\n      if (!item) {\n        var prevItem = prevItemKeys[key];\n        if (prevItem) {\n          item = prevItem;\n          if (info.data) {\n            item.data = info.data;\n          }\n          if (info.element) {\n            item.element = info.element;\n          }\n        } else {\n          item = new InfiniteGridItem(horizontal, __assign(__assign({}, info), {\n            key: key\n          }));\n        }\n        nextItemKeys[key] = item;\n      }\n      return item;\n    });\n    return nextItems;\n  };\n  __proto._registerGroups = function (groups) {\n    var nextGroupKeys = {};\n    groups.forEach(function (group) {\n      nextGroupKeys[group.groupKey] = group;\n    });\n    this.groups = groups;\n    this.groupKeys = nextGroupKeys;\n    this.groupItems = this._getGroupItems();\n  };\n  __proto._splitVirtualGroups = function (direction, nextGroups) {\n    var groups = splitVirtualGroups(this.groups, direction, nextGroups);\n    var itemKeys = this.itemKeys;\n    groups.forEach(function (_a) {\n      var renderItems = _a.renderItems;\n      renderItems.forEach(function (item) {\n        itemKeys[item.key] = item;\n      });\n    });\n    return groups;\n  };\n  __proto._mergeVirtualGroups = function (groups) {\n    var itemKeys = this.itemKeys;\n    var groupKeys = this.groupKeys;\n    groups.forEach(function (group) {\n      var prevGroup = groupKeys[group.groupKey];\n      if (!prevGroup) {\n        return;\n      }\n      var items = group.items;\n      if (items.every(function (item) {\n        return item.mountState === MOUNT_STATE.UNCHECKED;\n      })) {\n        prevGroup.renderItems.forEach(function (item) {\n          if (item.type === ITEM_TYPE.VIRTUAL && !itemKeys[item.key]) {\n            items.push(item);\n            itemKeys[item.key] = item;\n          }\n        });\n      }\n    });\n    return groups;\n  };\n  __proto._updatePlaceholder = function (items) {\n    if (items === void 0) {\n      items = this.groupItems;\n    }\n    var placeholder = this._placeholder;\n    if (!placeholder) {\n      return;\n    }\n    items.filter(function (item) {\n      return item.type === ITEM_TYPE.VIRTUAL;\n    }).forEach(function (item) {\n      setPlaceholder(item, placeholder);\n    });\n  };\n  __proto._makeGrid = function () {\n    var GridConstructor = this.options.gridConstructor;\n    var gridOptions = this.gridOptions;\n    var container = this.containerElement;\n    return new GridConstructor(container, __assign(__assign({}, gridOptions), {\n      useFit: false,\n      autoResize: false,\n      useResizeObserver: false,\n      observeChildren: false,\n      renderOnPropertyChange: false,\n      externalContainerManager: this.containerManager,\n      externalItemRenderer: this.itemRenderer\n    }));\n  };\n  __proto._getLoadingGroup = function () {\n    var loadingGrid = this._loadingGrid;\n    var items = loadingGrid.getItems();\n    return {\n      groupKey: LOADING_GROUP_KEY,\n      type: GROUP_TYPE.NORMAL,\n      grid: loadingGrid,\n      items: items,\n      renderItems: items\n    };\n  };\n  __proto._getLoadingItem = function () {\n    return this._loadingGrid.getLoadingItem();\n  };\n  GroupManager.defaultOptions = __assign(__assign({}, Grid.defaultOptions), {\n    appliedItemChecker: function () {\n      return false;\n    },\n    gridConstructor: null,\n    gridOptions: {}\n  });\n  GroupManager.propertyTypes = __assign(__assign({}, Grid.propertyTypes), {\n    gridConstructor: PROPERTY_TYPE.PROPERTY,\n    gridOptions: PROPERTY_TYPE.PROPERTY\n  });\n  GroupManager = __decorate([GetterSetter], GroupManager);\n  return GroupManager;\n}(Grid);\nvar Infinite = /*#__PURE__*/function (_super) {\n  __extends(Infinite, _super);\n  function Infinite(options) {\n    var _this = _super.call(this) || this;\n    _this.startCursor = -1;\n    _this.endCursor = -1;\n    _this.size = 0;\n    _this.items = [];\n    _this.itemKeys = {};\n    _this.options = __assign({\n      threshold: 0,\n      useRecycle: true,\n      defaultDirection: \"end\"\n    }, options);\n    return _this;\n  }\n  var __proto = Infinite.prototype;\n  __proto.scroll = function (scrollPos) {\n    var _a, _b;\n    var prevStartCursor = this.startCursor;\n    var prevEndCursor = this.endCursor;\n    var items = this.items;\n    var length = items.length;\n    var size = this.size;\n    var _c = this.options,\n      defaultDirection = _c.defaultDirection,\n      threshold = _c.threshold,\n      useRecycle = _c.useRecycle;\n    var isDirectionEnd = defaultDirection === \"end\";\n    if (!length) {\n      this.trigger(isDirectionEnd ? \"requestAppend\" : \"requestPrepend\", {\n        key: undefined,\n        isVirtual: false\n      });\n      return;\n    } else if (prevStartCursor === -1 || prevEndCursor === -1) {\n      var nextCursor = isDirectionEnd ? 0 : length - 1;\n      this.trigger(\"change\", {\n        prevStartCursor: prevStartCursor,\n        prevEndCursor: prevEndCursor,\n        nextStartCursor: nextCursor,\n        nextEndCursor: nextCursor\n      });\n      return;\n    }\n    var endScrollPos = scrollPos + size;\n    var startEdgePos = Math.max.apply(Math, items[prevStartCursor].startOutline);\n    var endEdgePos = Math.min.apply(Math, items[prevEndCursor].endOutline);\n    var visibles = items.map(function (item) {\n      var startOutline = item.startOutline,\n        endOutline = item.endOutline;\n      if (!startOutline.length || !endOutline.length || isFlatOutline(startOutline, endOutline)) {\n        return false;\n      }\n      var startPos = Math.min.apply(Math, startOutline);\n      var endPos = Math.max.apply(Math, endOutline);\n      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n        return true;\n      }\n      return false;\n    });\n    var hasStartItems = 0 < prevStartCursor;\n    var hasEndItems = prevEndCursor < length - 1;\n    var isStart = scrollPos <= startEdgePos + threshold;\n    var isEnd = endScrollPos >= endEdgePos - threshold;\n    var nextStartCursor = visibles.indexOf(true);\n    var nextEndCursor = visibles.lastIndexOf(true);\n    if (nextStartCursor === -1) {\n      nextStartCursor = prevStartCursor;\n      nextEndCursor = prevEndCursor;\n    }\n    if (!useRecycle) {\n      nextStartCursor = Math.min(nextStartCursor, prevStartCursor);\n      nextEndCursor = Math.max(nextEndCursor, prevEndCursor);\n    }\n    if (nextStartCursor === prevStartCursor && hasStartItems && isStart) {\n      nextStartCursor -= 1;\n    }\n    if (nextEndCursor === prevEndCursor && hasEndItems && isEnd) {\n      nextEndCursor += 1;\n    }\n    var nextVisibleItems = items.slice(nextStartCursor, nextEndCursor + 1);\n    // It must contain no virtual items.\n    if (nextVisibleItems.every(function (item) {\n      return item.isVirtual === true;\n    })) {\n      // The real item can be in either the start or end direction.\n      var hasRealItem = false;\n      for (var i = nextStartCursor - 1; i >= 0; --i) {\n        if (!items[i].isVirtual) {\n          nextStartCursor = i;\n          hasRealItem = true;\n          break;\n        }\n      }\n      if (!hasRealItem) {\n        for (var i = nextEndCursor + 1; i < length; ++i) {\n          if (!items[i].isVirtual) {\n            nextEndCursor = i;\n            hasRealItem = true;\n            break;\n          }\n        }\n      }\n      if (hasRealItem) {\n        nextVisibleItems = items.slice(nextStartCursor, nextEndCursor + 1);\n      }\n    }\n    var hasVirtualItems = nextVisibleItems.some(function (item) {\n      return item.isVirtual === true;\n    });\n    if (prevStartCursor !== nextStartCursor || prevEndCursor !== nextEndCursor) {\n      this.trigger(\"change\", {\n        prevStartCursor: prevStartCursor,\n        prevEndCursor: prevEndCursor,\n        nextStartCursor: nextStartCursor,\n        nextEndCursor: nextEndCursor\n      });\n      if (!hasVirtualItems) {\n        return;\n      }\n    }\n    // If a virtual item is included, a requestPrepend (or requestAppend) event is triggered.\n    if (hasVirtualItems) {\n      var isStartVirtual = (_a = nextVisibleItems[0]) === null || _a === void 0 ? void 0 : _a.isVirtual;\n      var isEndVirtual = (_b = nextVisibleItems[nextVisibleItems.length - 1]) === null || _b === void 0 ? void 0 : _b.isVirtual;\n      if ((!isDirectionEnd || !isEnd) && isStartVirtual) {\n        var realItemIndex = findIndex(nextVisibleItems, function (item) {\n          return !item.isVirtual;\n        });\n        var endVirtualItemIndex = (realItemIndex === -1 ? nextVisibleItems.length : realItemIndex) - 1;\n        if (nextVisibleItems[endVirtualItemIndex]) {\n          this.trigger(\"requestPrepend\", {\n            key: realItemIndex > -1 ? nextVisibleItems[realItemIndex].key : undefined,\n            nextKey: nextVisibleItems[endVirtualItemIndex].key,\n            nextKeys: nextVisibleItems.slice(0, endVirtualItemIndex + 1).map(function (item) {\n              return item.key;\n            }),\n            isVirtual: true\n          });\n        }\n      } else if ((isDirectionEnd || !isStart) && isEndVirtual) {\n        var realItemIndex = findLastIndex(nextVisibleItems, function (item) {\n          return !item.isVirtual;\n        });\n        var startVirtualItemIndex = realItemIndex + 1;\n        if (nextVisibleItems[startVirtualItemIndex]) {\n          this.trigger(\"requestAppend\", {\n            key: realItemIndex > -1 ? nextVisibleItems[realItemIndex].key : undefined,\n            nextKey: nextVisibleItems[startVirtualItemIndex].key,\n            nextKeys: nextVisibleItems.slice(startVirtualItemIndex).map(function (item) {\n              return item.key;\n            }),\n            isVirtual: true\n          });\n        }\n      }\n    } else if (!this._requestVirtualItems()) {\n      if ((!isDirectionEnd || !isEnd) && isStart) {\n        this.trigger(\"requestPrepend\", {\n          key: items[prevStartCursor].key,\n          isVirtual: false\n        });\n      } else if ((isDirectionEnd || !isStart) && isEnd) {\n        this.trigger(\"requestAppend\", {\n          key: items[prevEndCursor].key,\n          isVirtual: false\n        });\n      }\n    }\n  };\n  /**\n   * Call the requestAppend or requestPrepend event to fill the virtual items.\n   * @ko virtual item을 채우기 위해 requestAppend 또는 requestPrepend 이벤트를 호출합니다.\n   * @return - Whether the event is called. <ko>이벤트를 호출했는지 여부.</ko>\n   */\n  __proto._requestVirtualItems = function () {\n    var isDirectionEnd = this.options.defaultDirection === \"end\";\n    var items = this.items;\n    var totalVisibleItems = this.getVisibleItems();\n    var visibleItems = totalVisibleItems.filter(function (item) {\n      return !item.isVirtual;\n    });\n    var totalVisibleLength = totalVisibleItems.length;\n    var visibleLength = visibleItems.length;\n    var startCursor = this.getStartCursor();\n    var endCursor = this.getEndCursor();\n    if (visibleLength === totalVisibleLength) {\n      return false;\n    } else if (visibleLength) {\n      var startKey_1 = visibleItems[0].key;\n      var endKey_1 = visibleItems[visibleLength - 1].key;\n      var startIndex = findIndex(items, function (item) {\n        return item.key === startKey_1;\n      }) - 1;\n      var endIndex = findIndex(items, function (item) {\n        return item.key === endKey_1;\n      }) + 1;\n      var isEnd = endIndex <= endCursor;\n      var isStart = startIndex >= startCursor;\n      // Fill the placeholder with the original item.\n      if ((isDirectionEnd || !isStart) && isEnd) {\n        this.trigger(\"requestAppend\", {\n          key: endKey_1,\n          nextKey: items[endIndex].key,\n          isVirtual: true\n        });\n        return true;\n      } else if ((!isDirectionEnd || !isEnd) && isStart) {\n        this.trigger(\"requestPrepend\", {\n          key: startKey_1,\n          nextKey: items[startIndex].key,\n          isVirtual: true\n        });\n        return true;\n      }\n    } else if (totalVisibleLength) {\n      var lastItem = totalVisibleItems[totalVisibleLength - 1];\n      if (isDirectionEnd) {\n        this.trigger(\"requestAppend\", {\n          nextKey: totalVisibleItems[0].key,\n          isVirtual: true\n        });\n      } else {\n        this.trigger(\"requestPrepend\", {\n          nextKey: lastItem.key,\n          isVirtual: true\n        });\n      }\n      return true;\n    }\n    return false;\n  };\n  __proto.setCursors = function (startCursor, endCursor) {\n    this.startCursor = startCursor;\n    this.endCursor = endCursor;\n  };\n  __proto.setSize = function (size) {\n    this.size = size;\n  };\n  __proto.getStartCursor = function () {\n    return this.startCursor;\n  };\n  __proto.getEndCursor = function () {\n    return this.endCursor;\n  };\n  __proto.isLoading = function (direction) {\n    var startCursor = this.startCursor;\n    var endCursor = this.endCursor;\n    var items = this.items;\n    var firstItem = items[startCursor];\n    var lastItem = items[endCursor];\n    var length = items.length;\n    if (direction === DIRECTION.END && endCursor > -1 && endCursor < length - 1 && !lastItem.isVirtual && !isFlatOutline(lastItem.startOutline, lastItem.endOutline)) {\n      return false;\n    }\n    if (direction === DIRECTION.START && startCursor > 0 && !firstItem.isVirtual && !isFlatOutline(firstItem.startOutline, firstItem.endOutline)) {\n      return false;\n    }\n    return true;\n  };\n  __proto.setItems = function (nextItems) {\n    this.items = nextItems;\n    var itemKeys = {};\n    nextItems.forEach(function (item) {\n      itemKeys[item.key] = item;\n    });\n    this.itemKeys = itemKeys;\n  };\n  __proto.syncItems = function (nextItems) {\n    var prevItems = this.items;\n    var prevStartCursor = this.startCursor;\n    var prevEndCursor = this.endCursor;\n    var _a = getNextCursors(this.items.map(function (item) {\n        return item.key;\n      }), nextItems.map(function (item) {\n        return item.key;\n      }), prevStartCursor, prevEndCursor),\n      nextStartCursor = _a.startCursor,\n      nextEndCursor = _a.endCursor;\n    // sync items between cursors\n    var isChange = nextEndCursor - nextStartCursor !== prevEndCursor - prevStartCursor || prevStartCursor === -1 || nextStartCursor === -1;\n    if (!isChange) {\n      var prevVisibleItems = prevItems.slice(prevStartCursor, prevEndCursor + 1);\n      var nextVisibleItems = nextItems.slice(nextStartCursor, nextEndCursor + 1);\n      var visibleResult = diff(prevVisibleItems, nextVisibleItems, function (item) {\n        return item.key;\n      });\n      isChange = visibleResult.added.length > 0 || visibleResult.removed.length > 0 || visibleResult.changed.length > 0;\n    }\n    this.setItems(nextItems);\n    this.setCursors(nextStartCursor, nextEndCursor);\n    return isChange;\n  };\n  __proto.getItems = function () {\n    return this.items;\n  };\n  __proto.getVisibleItems = function () {\n    var startCursor = this.startCursor;\n    var endCursor = this.endCursor;\n    if (startCursor === -1) {\n      return [];\n    }\n    return this.items.slice(startCursor, endCursor + 1);\n  };\n  __proto.getSize = function () {\n    return this.size;\n  };\n  __proto.getItemByKey = function (key) {\n    return this.itemKeys[key];\n  };\n  __proto.getItemPartByKey = function (partKey) {\n    var itemPart;\n    this.items.forEach(function (item) {\n      var _a;\n      (_a = item.parts) === null || _a === void 0 ? void 0 : _a.forEach(function (part) {\n        if (part.key === partKey) {\n          itemPart = part;\n        }\n      });\n    });\n    return itemPart;\n  };\n  __proto.getScrollSize = function () {\n    var items = this.items;\n    var length = items.length;\n    if (!length) {\n      return 0;\n    }\n    return Math.max.apply(Math, __spreadArray([0], items[length - 1].endOutline, false));\n  };\n  __proto.getVisibleArea = function (scrollPos, direction) {\n    if (direction === void 0) {\n      direction = this.options.defaultDirection;\n    }\n    var isDirectionEnd = direction === DIRECTION.END;\n    var visibleItems = this.getRenderedVisibleItems();\n    if (!visibleItems.length) {\n      return null;\n    }\n    var visibleItem = visibleItems[isDirectionEnd ? 0 : length - 1];\n    var itemPos = isDirectionEnd ? Math.min.apply(Math, visibleItem.startOutline) : Math.max.apply(Math, visibleItem.endOutline);\n    var pos = itemPos;\n    var itemPart;\n    if (isDirectionEnd) {\n      visibleItems.forEach(function (item) {\n        var _a;\n        (_a = item.parts) === null || _a === void 0 ? void 0 : _a.forEach(function (part) {\n          if (itemPart && itemPart.pos >= part.pos) {\n            return;\n          }\n          if (pos < part.pos && part.pos <= scrollPos) {\n            itemPart = part;\n            pos = part.pos;\n          }\n        });\n      });\n    } else {\n      visibleItems.forEach(function (item) {\n        var _a;\n        (_a = item.parts) === null || _a === void 0 ? void 0 : _a.forEach(function (part) {\n          var endPos = part.pos + part.size;\n          if (itemPart && itemPart.pos + itemPart.size <= endPos) {\n            return;\n          }\n          if (pos > endPos && endPos >= scrollPos) {\n            itemPart = part;\n            pos = endPos;\n          }\n        });\n      });\n    }\n    return {\n      item: visibleItem,\n      part: itemPart\n    };\n  };\n  __proto.getRenderedVisibleItems = function () {\n    var items = this.getVisibleItems();\n    var rendered = items.map(function (_a) {\n      var startOutline = _a.startOutline,\n        endOutline = _a.endOutline;\n      var length = startOutline.length;\n      if (length === 0 || length !== endOutline.length) {\n        return false;\n      }\n      return startOutline.some(function (pos, i) {\n        return endOutline[i] !== pos;\n      });\n    });\n    var startIndex = rendered.indexOf(true);\n    var endIndex = rendered.lastIndexOf(true);\n    return endIndex === -1 ? [] : items.slice(startIndex, endIndex + 1);\n  };\n  __proto.destroy = function () {\n    this.off();\n    this.startCursor = -1;\n    this.endCursor = -1;\n    this.items = [];\n    this.size = 0;\n  };\n  return Infinite;\n}(Component);\nvar Renderer = /*#__PURE__*/function (_super) {\n  __extends(Renderer, _super);\n  function Renderer() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this.items = [];\n    _this.container = null;\n    _this.rendererKey = 0;\n    _this._updateTimer = 0;\n    _this._state = {};\n    _this._isItemChanged = false;\n    return _this;\n  }\n  var __proto = Renderer.prototype;\n  __proto.updateKey = function () {\n    this.rendererKey = Date.now();\n  };\n  __proto.getItems = function () {\n    return this.items;\n  };\n  __proto.setContainer = function (container) {\n    this.container = container;\n  };\n  __proto.render = function (nextItems, state) {\n    return this.syncItems(nextItems, state);\n  };\n  __proto.update = function (state) {\n    var _this = this;\n    if (state === void 0) {\n      state = {};\n    }\n    this._state = __assign(__assign({}, this._state), state);\n    this.trigger(\"update\", {\n      state: state\n    });\n    clearTimeout(this._updateTimer);\n    this._updateTimer = window.setTimeout(function () {\n      _this.trigger(\"requestUpdate\", {\n        state: state\n      });\n    });\n  };\n  __proto.updated = function (nextElements) {\n    var _a, _b;\n    if (nextElements === void 0) {\n      nextElements = (_b = (_a = this.container) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];\n    }\n    var diffResult = this._diffResult;\n    var isChanged = !!(diffResult.added.length || diffResult.removed.length || diffResult.changed.length);\n    var state = this._state;\n    var isItemChanged = this._isItemChanged;\n    var nextItems = diffResult.list;\n    this._isItemChanged = false;\n    this._state = {};\n    this.items = nextItems;\n    nextItems.forEach(function (item, i) {\n      item.element = nextElements[i];\n    });\n    this.trigger(\"updated\", {\n      items: nextItems,\n      elements: toArray(nextElements),\n      diffResult: this._diffResult,\n      state: state,\n      isItemChanged: isItemChanged,\n      isChanged: isChanged\n    });\n    return isChanged;\n  };\n  __proto.syncItems = function (items, state) {\n    if (state === void 0) {\n      state = {};\n    }\n    var rendererKey = this.rendererKey;\n    var prevItems = this.items;\n    var nextItems = items.map(function (item) {\n      return __assign(__assign({}, item), {\n        renderKey: \"\".concat(rendererKey, \"_\").concat(item.key)\n      });\n    });\n    var result = diff(prevItems, nextItems, function (item) {\n      return item.renderKey;\n    });\n    this._isItemChanged = !!result.added.length || !!result.removed.length || !!result.changed.length;\n    this._state = __assign(__assign({}, this._state), state);\n    this._diffResult = result;\n    return result;\n  };\n  __proto.destroy = function () {\n    this.off();\n  };\n  return Renderer;\n}(Component);\nvar VanillaRenderer = /*#__PURE__*/function (_super) {\n  __extends(VanillaRenderer, _super);\n  function VanillaRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  var __proto = VanillaRenderer.prototype;\n  __proto.render = function (nextItems, state) {\n    var container = this.container;\n    var result = _super.prototype.render.call(this, nextItems, state);\n    var prevList = result.prevList,\n      removed = result.removed,\n      ordered = result.ordered,\n      added = result.added,\n      list = result.list;\n    var diffList = __spreadArray([], prevList, true);\n    removed.forEach(function (index) {\n      diffList.splice(index, 1);\n      container.removeChild(prevList[index].element);\n    });\n    ordered.forEach(function (_a) {\n      var _b, _c;\n      var prevIndex = _a[0],\n        nextIndex = _a[1];\n      var item = diffList.splice(prevIndex, 1)[0];\n      diffList.splice(nextIndex, 0, item);\n      container.insertBefore(item.element, (_c = (_b = diffList[nextIndex + 1]) === null || _b === void 0 ? void 0 : _b.element) !== null && _c !== void 0 ? _c : null);\n    });\n    added.forEach(function (index) {\n      var _a, _b;\n      var item = list[index];\n      diffList.splice(index, 0, item);\n      container.insertBefore(item.element, (_b = (_a = diffList[index + 1]) === null || _a === void 0 ? void 0 : _a.element) !== null && _b !== void 0 ? _b : null);\n    });\n    this.updated(container.children);\n    return result;\n  };\n  return VanillaRenderer;\n}(Renderer);\nvar VanillaGridRenderer = /*#__PURE__*/function (_super) {\n  __extends(VanillaGridRenderer, _super);\n  function VanillaGridRenderer() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  var __proto = VanillaGridRenderer.prototype;\n  __proto.syncItems = function (nextItems) {\n    var result = _super.prototype.syncItems.call(this, nextItems);\n    var added = result.added,\n      list = result.list;\n    added.forEach(function (index) {\n      var orgItem = nextItems[index].orgItem;\n      if (orgItem.html && !orgItem.element) {\n        orgItem.element = convertHTMLtoElement(orgItem.html)[0];\n      }\n      list[index].element = orgItem.element;\n    });\n    return result;\n  };\n  return VanillaGridRenderer;\n}(VanillaRenderer);\nvar ScrollManager = /*#__PURE__*/function (_super) {\n  __extends(ScrollManager, _super);\n  function ScrollManager(wrapper, options) {\n    var _this = _super.call(this) || this;\n    _this.wrapper = wrapper;\n    _this.prevScrollPos = null;\n    _this.scrollOffset = 0;\n    _this.contentSize = 0;\n    _this._isScrollIssue = IS_IOS;\n    _this._onCheck = function () {\n      var prevScrollPos = _this.getScrollPos();\n      var nextScrollPos = _this.getOrgScrollPos();\n      _this.setScrollPos(nextScrollPos);\n      if (prevScrollPos === null || _this._isScrollIssue && nextScrollPos === 0 || prevScrollPos === nextScrollPos) {\n        nextScrollPos && (_this._isScrollIssue = false);\n        return;\n      }\n      _this._isScrollIssue = false;\n      _this.trigger(new ComponentEvent(\"scroll\", {\n        direction: prevScrollPos < nextScrollPos ? \"end\" : \"start\",\n        scrollPos: nextScrollPos,\n        relativeScrollPos: _this.getRelativeScrollPos()\n      }));\n    };\n    _this.options = __assign({\n      container: false,\n      containerTag: \"div\",\n      horizontal: false,\n      scrollContainer: null\n    }, options);\n    _this._init();\n    return _this;\n  }\n  var __proto = ScrollManager.prototype;\n  __proto.getWrapper = function () {\n    return this.wrapper;\n  };\n  __proto.getContainer = function () {\n    return this.container;\n  };\n  __proto.getScrollContainer = function () {\n    return this.scrollContainer;\n  };\n  __proto.getScrollOffset = function () {\n    return this.scrollOffset;\n  };\n  __proto.getContentSize = function () {\n    return this.contentSize;\n  };\n  __proto.getRelativeScrollPos = function () {\n    return (this.prevScrollPos || 0) - this.scrollOffset;\n  };\n  __proto.getScrollPos = function () {\n    return this.prevScrollPos;\n  };\n  __proto.setScrollPos = function (pos) {\n    this.prevScrollPos = pos;\n  };\n  __proto.getOrgScrollPos = function () {\n    var eventTarget = this.eventTarget;\n    var horizontal = this.options.horizontal;\n    var prop = \"scroll\".concat(horizontal ? \"Left\" : \"Top\");\n    if (isWindow(eventTarget)) {\n      return window[horizontal ? \"pageXOffset\" : \"pageYOffset\"] || document.documentElement[prop] || document.body[prop];\n    } else {\n      return eventTarget[prop];\n    }\n  };\n  __proto.setStatus = function (status) {\n    this.contentSize = status.contentSize;\n    this.scrollOffset = status.scrollOffset;\n    this.prevScrollPos = status.prevScrollPos;\n    this.scrollTo(this.prevScrollPos);\n  };\n  __proto.getStatus = function () {\n    return {\n      contentSize: this.contentSize,\n      scrollOffset: this.scrollOffset,\n      prevScrollPos: this.prevScrollPos\n    };\n  };\n  __proto.scrollTo = function (pos) {\n    var eventTarget = this.eventTarget;\n    var horizontal = this.options.horizontal;\n    var _a = horizontal ? [pos, 0] : [0, pos],\n      x = _a[0],\n      y = _a[1];\n    if (isWindow(eventTarget)) {\n      eventTarget.scroll(x, y);\n    } else {\n      eventTarget.scrollLeft = x;\n      eventTarget.scrollTop = y;\n    }\n  };\n  __proto.scrollBy = function (pos) {\n    if (!pos) {\n      return;\n    }\n    var eventTarget = this.eventTarget;\n    var horizontal = this.options.horizontal;\n    var _a = horizontal ? [pos, 0] : [0, pos],\n      x = _a[0],\n      y = _a[1];\n    this.prevScrollPos += pos;\n    if (isWindow(eventTarget)) {\n      eventTarget.scrollBy(x, y);\n    } else {\n      eventTarget.scrollLeft += x;\n      eventTarget.scrollTop += y;\n    }\n  };\n  __proto.resize = function () {\n    var scrollContainer = this.scrollContainer;\n    var horizontal = this.options.horizontal;\n    var isBody = scrollContainer === document.body;\n    var scrollContainerRect = isBody ? {\n      top: 0,\n      left: 0\n    } : scrollContainer.getBoundingClientRect();\n    var containerRect = this.container.getBoundingClientRect();\n    this.scrollOffset = (this.getOrgScrollPos() || 0) + (horizontal ? containerRect.left - scrollContainerRect.left : containerRect.top - scrollContainerRect.top);\n    if (isBody) {\n      this.contentSize = horizontal ? window.innerWidth : window.innerHeight;\n    } else {\n      this.contentSize = horizontal ? scrollContainer.offsetWidth : scrollContainer.offsetHeight;\n    }\n  };\n  __proto.destroy = function () {\n    var container = this.container;\n    this.eventTarget.removeEventListener(\"scroll\", this._onCheck);\n    if (this._isCreateElement) {\n      var scrollContainer = this.scrollContainer;\n      var fragment_1 = document.createDocumentFragment();\n      var childNodes = toArray(container.childNodes);\n      scrollContainer.removeChild(container);\n      childNodes.forEach(function (childNode) {\n        fragment_1.appendChild(childNode);\n      });\n      scrollContainer.appendChild(fragment_1);\n    } else if (this.options.container) {\n      container.style.cssText = this._orgCSSText;\n    }\n  };\n  __proto._init = function () {\n    var _a;\n    var _b = this.options,\n      containerOption = _b.container,\n      containerTag = _b.containerTag,\n      horizontal = _b.horizontal,\n      scrollContainerOption = _b.scrollContainer;\n    var wrapper = this.wrapper;\n    var scrollContainer = wrapper;\n    var container = wrapper;\n    var containerCSSText = \"\";\n    if (!containerOption) {\n      scrollContainer = findTarget(scrollContainerOption) || document.body;\n      containerCSSText = container.style.cssText;\n    } else {\n      if (containerOption === true) {\n        // Create Container\n        container = document.createElement(containerTag);\n        container.style.position = \"relative\";\n        container.className = CONTAINER_CLASS_NAME;\n        var childNodes = toArray(scrollContainer.childNodes);\n        childNodes.forEach(function (childNode) {\n          container.appendChild(childNode);\n        });\n        scrollContainer.appendChild(container);\n        this._isCreateElement = true;\n      } else {\n        // Find Container\n        container = findTarget(containerOption);\n      }\n      containerCSSText = container.style.cssText;\n      var style = scrollContainer.style;\n      _a = horizontal ? [\"scroll\", \"hidden\"] : [\"hidden\", \"scroll\"], style.overflowX = _a[0], style.overflowY = _a[1];\n      if (horizontal) {\n        container.style.height = \"100%\";\n      }\n    }\n    var eventTarget = scrollContainer === document.body ? window : scrollContainer;\n    eventTarget.addEventListener(\"scroll\", this._onCheck);\n    this._orgCSSText = containerCSSText;\n    this.container = container;\n    this.scrollContainer = scrollContainer;\n    this.eventTarget = eventTarget;\n    this.resize();\n    this.setScrollPos(this.getOrgScrollPos());\n  };\n  return ScrollManager;\n}(Component);\n\n/**\n * A module used to arrange items including content infinitely according to layout type. With this module, you can implement various layouts composed of different items whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 아이템을 레이아웃 타입에 따라 무한으로 배치하는 모듈. 다양한 크기의 아이템을 다양한 레이아웃으로 배치할 수 있다. 아이템의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @example\n```html\n<ul id=\"grid\">\n  <li class=\"card\">\n    <div>test1</div>\n  </li>\n  <li class=\"card\">\n    <div>test2</div>\n  </li>\n  <li class=\"card\">\n    <div>test3</div>\n  </li>\n  <li class=\"card\">\n    <div>test4</div>\n  </li>\n  <li class=\"card\">\n    <div>test5</div>\n  </li>\n  <li class=\"card\">\n    <div>test6</div>\n  </li>\n</ul>\n<script>\nimport { MasonryInfiniteGrid } from \"@egjs/infinitegrid\";\nvar some = new MasonryInfiniteGrid(\"#grid\").on(\"renderComplete\", function(e) {\n  // ...\n});\n// If you already have items in the container, call \"layout\" method.\nsome.renderItems();\n</script>\n```\n */\nvar InfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(InfiniteGrid, _super);\n  /**\n   * @param - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n   * @param - The option object of the InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n   */\n  function InfiniteGrid(wrapper, options) {\n    var _this = _super.call(this) || this;\n    _this._waitType = \"\";\n    _this._onScroll = function (_a) {\n      var direction = _a.direction,\n        scrollPos = _a.scrollPos,\n        relativeScrollPos = _a.relativeScrollPos;\n      _this._scroll();\n      /**\n       * This event is fired when scrolling.\n       * @ko 스크롤하면 발생하는 이벤트이다.\n       * @event InfiniteGrid#changeScroll\n       * @param {InfiniteGrid.OnChangeScroll} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       */\n      _this.trigger(new ComponentEvent(INFINITEGRID_EVENTS.CHANGE_SCROLL, {\n        direction: direction,\n        scrollPos: scrollPos,\n        relativeScrollPos: relativeScrollPos\n      }));\n    };\n    _this._onChange = function (e) {\n      _this.setCursors(e.nextStartCursor, e.nextEndCursor);\n    };\n    _this._onRendererUpdated = function (e) {\n      var renderedItems = e.items;\n      renderedItems.forEach(function (item) {\n        // set grid element\n        var gridItem = item.orgItem;\n        gridItem.element = item.element;\n      });\n      if (!e.isChanged) {\n        _this._checkEndLoading();\n        _this._scroll();\n        return;\n      }\n      var _a = e.diffResult,\n        added = _a.added,\n        removed = _a.removed,\n        prevList = _a.prevList,\n        list = _a.list;\n      removed.forEach(function (index) {\n        var orgItem = prevList[index].orgItem;\n        if (orgItem.mountState !== MOUNT_STATE.UNCHECKED) {\n          orgItem.mountState = MOUNT_STATE.UNMOUNTED;\n        }\n      });\n      var horizontal = _this.options.horizontal;\n      var addedItems = added.map(function (index) {\n        var gridItem = list[index].orgItem;\n        var element = gridItem.element;\n        if (gridItem.type === ITEM_TYPE.VIRTUAL) {\n          var cssRect = __assign({}, gridItem.cssRect);\n          var rect = gridItem.rect;\n          if (!cssRect.width && rect.width) {\n            cssRect.width = rect.width;\n          }\n          if (!cssRect.height && rect.height) {\n            cssRect.height = rect.height;\n          }\n          // virtual item\n          return new GridItem(horizontal, {\n            element: element,\n            cssRect: cssRect\n          });\n        }\n        return gridItem;\n      });\n      var containerManager = _this.containerManager;\n      if (_this.options.observeChildren) {\n        containerManager.unobserveChildren(removed.map(function (index) {\n          return prevList[index].element;\n        }));\n        containerManager.observeChildren(added.map(function (index) {\n          return list[index].element;\n        }));\n      }\n      var _b = e.state,\n        isRestore = _b.isRestore,\n        isResize = _b.isResize;\n      _this.itemRenderer.renderItems(addedItems);\n      if (isRestore) {\n        _this._onRenderComplete({\n          mounted: added.map(function (index) {\n            return list[index].orgItem;\n          }),\n          updated: [],\n          isResize: false,\n          direction: _this.defaultDirection\n        });\n      }\n      if (!isRestore || isResize || e.isItemChanged) {\n        _this.groupManager.renderItems();\n      }\n    };\n    _this._onResize = function (e) {\n      if (e.isResizeContainer) {\n        _this._renderItems({\n          useResize: true\n        }, true);\n      } else {\n        var updatedItems = getUpdatedItems(_this.getVisibleItems(), e.childEntries);\n        if (updatedItems.length > 0) {\n          _this.updateItems(updatedItems);\n        }\n      }\n    };\n    _this._onRequestAppend = function (e) {\n      /**\n       * The event is fired when scrolling reaches the end or when data for a virtual group is required.\n       * @ko 스크롤이 끝에 도달하거나 virtual 그룹에 대한 데이터가 필요한 경우 이벤트가 발생한다.\n       * @event InfiniteGrid#requestAppend\n       * @param {InfiniteGrid.OnRequestAppend} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       */\n      _this._onRequestInsert(DIRECTION.END, INFINITEGRID_EVENTS.REQUEST_APPEND, e);\n    };\n    _this._onRequestPrepend = function (e) {\n      /**\n       * The event is fired when scrolling reaches the start or when data for a virtual group is required.\n       * @ko 스크롤이 끝에 도달하거나 virtual 그룹에 대한 데이터가 필요한 경우 이벤트가 발생한다.\n       * @event InfiniteGrid#requestPrepend\n       * @param {InfiniteGrid.OnRequestPrepend} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       */\n      _this._onRequestInsert(DIRECTION.START, INFINITEGRID_EVENTS.REQUEST_PREPEND, e);\n    };\n    _this._onContentError = function (_a) {\n      var element = _a.element,\n        target = _a.target,\n        item = _a.item,\n        update = _a.update;\n      /**\n       * The event is fired when scrolling reaches the start or when data for a virtual group is required.\n       * @ko 스크롤이 끝에 도달하거나 virtual 그룹에 대한 데이터가 필요한 경우 이벤트가 발생한다.\n       * @event InfiniteGrid#contentError\n       * @param {InfiniteGrid.OnContentError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       */\n      _this.trigger(new ComponentEvent(INFINITEGRID_EVENTS.CONTENT_ERROR, {\n        element: element,\n        target: target,\n        item: item,\n        update: update,\n        remove: function () {\n          _this.removeByKey(item.key);\n        }\n      }));\n    };\n    _this._onRenderComplete = function (_a) {\n      var isResize = _a.isResize,\n        mounted = _a.mounted,\n        updated = _a.updated,\n        direction = _a.direction;\n      var infinite = _this.infinite;\n      var scrollManager = _this.scrollManager;\n      var scrollPos = scrollManager.getRelativeScrollPos();\n      var prevScrollSize = infinite.getScrollSize();\n      var prevContainerSize = infinite.getSize();\n      var prevVisibleArea = infinite.getVisibleArea(scrollPos, direction);\n      var isDirectionEnd = direction === DIRECTION.END;\n      _this._syncInfinite();\n      if (prevVisibleArea) {\n        var prevPart = prevVisibleArea.part;\n        var prevItem = prevVisibleArea.item;\n        var nextPart = void 0;\n        var nextItem = void 0;\n        if (prevPart) {\n          nextPart = infinite.getItemPartByKey(prevPart.key);\n        }\n        if (prevItem) {\n          nextItem = infinite.getItemByKey(prevItem.key);\n        }\n        if (nextPart || nextItem) {\n          var prevPos = 0;\n          var nextPos = 0;\n          if (nextPart) {\n            nextPos = nextPart.pos + (isDirectionEnd ? 0 : nextPart.size);\n            prevPos = prevPart.pos + (isDirectionEnd ? 0 : prevPart.size);\n          } else {\n            var prevStartPos = Math.min.apply(Math, prevItem.startOutline);\n            var prevEndPos = Math.max.apply(Math, prevItem.endOutline);\n            var nextStartPos = Math.min.apply(Math, nextItem.startOutline);\n            var nextEndPos = Math.max.apply(Math, nextItem.endOutline);\n            nextPos = isDirectionEnd ? nextStartPos : nextEndPos;\n            prevPos = isDirectionEnd ? prevStartPos : prevEndPos;\n          }\n          var offset = nextPos - prevPos;\n          // If reversed, scroll size (case where container size is reduced)\n          if (offset < 0) {\n            var nextScrollSize = infinite.getScrollSize();\n            var nextContainerSize = infinite.getSize();\n            var endOffset = Math.max(scrollPos - Math.max(0, prevScrollSize - prevContainerSize), 0);\n            var nextScollPos = Math.min(scrollPos, Math.max(0, nextScrollSize - nextContainerSize)) + endOffset;\n            // The scroll size is restored to the extent that it has been reduced.\n            offset += scrollPos - nextScollPos;\n          }\n          _this.scrollManager.scrollBy(offset);\n        }\n      }\n      var completeMounted = mounted.filter(function (item) {\n        return item.type !== ITEM_TYPE.LOADING;\n      });\n      /**\n       * This event is fired when the InfiniteGrid has completed rendering.\n       * @ko InfiniteGrid가 렌더링이 완료됐을 때 이벤트가 발생한다.\n       * @event InfiniteGrid#renderComplete\n       * @param {InfiniteGrid.OnRenderComplete} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n       */\n      _this.trigger(new ComponentEvent(INFINITEGRID_EVENTS.RENDER_COMPLETE, {\n        isResize: isResize,\n        direction: direction,\n        mounted: completeMounted,\n        updated: updated.filter(function (item) {\n          return item.type !== ITEM_TYPE.LOADING;\n        }),\n        startCursor: _this.getStartCursor(),\n        endCursor: _this.getEndCursor(),\n        items: _this.getVisibleItems(true),\n        groups: _this.getVisibleGroups(true)\n      }));\n      var isUpdate = _this.groupManager.shouldRerenderItems();\n      if (completeMounted.length || updated.length) {\n        isUpdate || (isUpdate = !!_this.groupManager.endLoading());\n      }\n      if (isUpdate) {\n        _this._update();\n      } else {\n        _this._checkEndLoading();\n        _this._scroll();\n      }\n    };\n    _this.options = __assign(__assign(__assign({}, _this.constructor.defaultOptions), {\n      renderer: new VanillaGridRenderer().on(\"requestUpdate\", function () {\n        return _this._render();\n      })\n    }), options);\n    var _a = _this.options,\n      gridConstructor = _a.gridConstructor,\n      containerTag = _a.containerTag,\n      container = _a.container,\n      renderer = _a.renderer,\n      threshold = _a.threshold,\n      useRecycle = _a.useRecycle,\n      scrollContainer = _a.scrollContainer,\n      appliedItemChecker = _a.appliedItemChecker,\n      gridOptions = __rest(_a, [\"gridConstructor\", \"containerTag\", \"container\", \"renderer\", \"threshold\", \"useRecycle\", \"scrollContainer\", \"appliedItemChecker\"]);\n    // options.container === false, wrapper = container, scrollContainer = document.body\n    // options.container === true, wrapper = scrollContainer, container = wrapper's child\n    // options.container === string,\n    var horizontal = gridOptions.horizontal,\n      attributePrefix = gridOptions.attributePrefix,\n      useTransform = gridOptions.useTransform,\n      percentage = gridOptions.percentage,\n      isConstantSize = gridOptions.isConstantSize,\n      isEqualSize = gridOptions.isEqualSize,\n      autoResize = gridOptions.autoResize,\n      useResizeObserver = gridOptions.useResizeObserver,\n      resizeDebounce = gridOptions.resizeDebounce,\n      maxResizeDebounce = gridOptions.maxResizeDebounce,\n      defaultDirection = gridOptions.defaultDirection,\n      useRoundedSize = gridOptions.useRoundedSize;\n    var wrapperElement = isString(wrapper) ? document.querySelector(wrapper) : wrapper;\n    var scrollManager = new ScrollManager(wrapperElement, {\n      scrollContainer: scrollContainer,\n      container: container,\n      containerTag: containerTag,\n      horizontal: horizontal\n    }).on({\n      scroll: _this._onScroll\n    });\n    var containerElement = scrollManager.getContainer();\n    var containerManager = new ContainerManager(containerElement, {\n      horizontal: horizontal,\n      autoResize: autoResize,\n      resizeDebounce: resizeDebounce,\n      maxResizeDebounce: maxResizeDebounce,\n      useResizeObserver: useResizeObserver\n    }).on(\"resize\", _this._onResize);\n    var itemRenderer = new ItemRenderer({\n      attributePrefix: attributePrefix,\n      horizontal: horizontal,\n      useTransform: useTransform,\n      percentage: percentage,\n      isEqualSize: isEqualSize,\n      isConstantSize: isConstantSize,\n      useRoundedSize: useRoundedSize\n    });\n    var infinite = new Infinite({\n      defaultDirection: defaultDirection,\n      useRecycle: useRecycle,\n      threshold: threshold\n    }).on({\n      \"change\": _this._onChange,\n      \"requestAppend\": _this._onRequestAppend,\n      \"requestPrepend\": _this._onRequestPrepend\n    });\n    infinite.setSize(scrollManager.getContentSize());\n    var groupManager = new GroupManager(containerElement, {\n      appliedItemChecker: appliedItemChecker,\n      gridConstructor: gridConstructor,\n      externalItemRenderer: itemRenderer,\n      externalContainerManager: containerManager,\n      gridOptions: gridOptions\n    });\n    groupManager.on({\n      \"renderComplete\": _this._onRenderComplete,\n      \"contentError\": _this._onContentError\n    });\n    renderer.setContainer(containerElement);\n    renderer.on(\"updated\", _this._onRendererUpdated);\n    _this.itemRenderer = itemRenderer;\n    _this.groupManager = groupManager;\n    _this.wrapperElement = wrapperElement;\n    _this.scrollManager = scrollManager;\n    _this.containerManager = containerManager;\n    _this.infinite = infinite;\n    _this.containerManager.resize();\n    return _this;\n  }\n  var __proto = InfiniteGrid.prototype;\n  InfiniteGrid_1 = InfiniteGrid;\n  /**\n   * Rearrange items to fit the grid and render them. When rearrange is complete, the `renderComplete` event is fired.\n   * @ko grid에 맞게 아이템을 재배치하고 렌더링을 한다. 배치가 완료되면 `renderComplete` 이벤트가 발생한다.\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   * @example\n   * ```ts\n   * import { MasonryInfiniteGrid } from \"@egjs/infinitegrid\";\n   * const grid = new MasonryInfiniteGrid();\n   *\n   * grid.on(\"renderComplete\", e => {\n   *   console.log(e);\n   * });\n   * grid.renderItems();\n   * ```\n   */\n  __proto.renderItems = function (options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this._renderItems(options);\n    return this;\n  };\n  /**\n   * Returns the wrapper element specified by the user.\n   * @ko 컨테이너 엘리먼트를 반환한다.\n   */\n  __proto.getWrapperElement = function () {\n    return this.scrollManager.getWrapper();\n  };\n  /**\n   * Returns the container element corresponding to the scroll area.\n   * @ko 스크롤 영역에 해당하는 컨테이너 엘리먼트를 반환한다.\n   */\n  __proto.getScrollContainerElement = function () {\n    return this.scrollManager.getScrollContainer();\n  };\n  /**\n   * Returns the container element containing item elements.\n   * @ko 아이템 엘리먼트들을 담긴 컨테이너 엘리먼트를 반환한다.\n   */\n  __proto.getContainerElement = function () {\n    return this.scrollManager.getContainer();\n  };\n  /**\n   * When items change, it synchronizes and renders items.\n   * @ko items가 바뀐 경우 동기화를 하고 렌더링을 한다.\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  __proto.syncItems = function (items) {\n    this.groupManager.syncItems(items);\n    this._syncGroups();\n    return this;\n  };\n  /**\n   * Change the currently visible groups.\n   * @ko 현재 보이는 그룹들을 바꾼다.\n   * @param - first index of visible groups. <ko>보이는 그룹의 첫번째 index.</ko>\n   * @param - last index of visible groups. <ko>보이는 그룹의 마지막 index.</ko>\n   * @param - Whether the first rendering has already been done. <ko>첫 렌더링이 이미 되어있는지 여부.</ko>\n   */\n  __proto.setCursors = function (startCursor, endCursor, useFirstRender) {\n    this.groupManager.setCursors(startCursor, endCursor);\n    this.infinite.setCursors(startCursor, endCursor);\n    if (useFirstRender) {\n      this.getVisibleItems().forEach(function (item) {\n        if (item.cssRect.top === INVISIBLE_POS) {\n          item.cssRect = {};\n        }\n      });\n      this._syncItems();\n    } else {\n      this._update();\n      this._checkEndLoading();\n    }\n    return this;\n  };\n  /**\n   * Returns the first index of visible groups.\n   * @ko 보이는 그룹들의 첫번째 index를 반환한다.\n   */\n  __proto.getStartCursor = function () {\n    return this.infinite.getStartCursor();\n  };\n  /**\n   * Returns the last index of visible groups.\n   * @ko 보이는 그룹들의 마지막 index를 반환한다.\n   */\n  __proto.getEndCursor = function () {\n    return this.infinite.getEndCursor();\n  };\n  /**\n   * Add items at the bottom(right) of the grid.\n   * @ko 아이템들을 grid 아래(오른쪽)에 추가한다.\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * ig.append(`<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.append([`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.append([HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  __proto.append = function (items, groupKey) {\n    return this.insert(-1, items, groupKey);\n  };\n  /**\n   * Add items at the top(left) of the grid.\n   * @ko 아이템들을 grid 위(왼쪽)에 추가한다.\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * ig.prepend(`<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.prepend([`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.prepend([HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  __proto.prepend = function (items, groupKey) {\n    return this.insert(0, items, groupKey);\n  };\n  /**\n   * Add items to a specific index.\n   * @ko 아이템들을 특정 index에 추가한다.\n   * @param - index to add <ko>추가하기 위한 index</ko>\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * ig.insert(2, `<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.insert(3, [`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.insert(4, [HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  __proto.insert = function (index, items, groupKey) {\n    var nextItemInfos = this.groupManager.getGroupItems();\n    var itemInfos = convertInsertedItems(items, groupKey);\n    if (index === -1) {\n      nextItemInfos.push.apply(nextItemInfos, itemInfos);\n    } else {\n      nextItemInfos.splice.apply(nextItemInfos, __spreadArray([index, 0], itemInfos, false));\n    }\n    return this.syncItems(nextItemInfos);\n  };\n  /**\n   * Add items based on group index.\n   * @ko group의 index 기준으로 item들을 추가한다.\n   * @param - group index to add <ko>추가하기 위한 group의 index</ko>\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * ig.insertByGroupIndex(2, `<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.insertByGroupIndex(3, [`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.insertByGroupIndex(4, [HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  __proto.insertByGroupIndex = function (groupIndex, items, groupKey) {\n    var nextGroupInfos = this.groupManager.getGroups();\n    var rightGroup = nextGroupInfos[groupIndex];\n    if (!rightGroup) {\n      return this.append(items, groupKey);\n    }\n    var nextItemInfos = this.groupManager.getGroupItems();\n    var rightGroupKey = rightGroup.groupKey;\n    var rightItemIndex = findIndex(nextItemInfos, function (item) {\n      return item.groupKey === rightGroupKey;\n    });\n    return this.insert(rightItemIndex, items, groupKey);\n  };\n  /**\n   * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n   * @ko 아이템의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n   * @param - STATUS_TYPE.NOT_REMOVE = Get all information about items. STATUS_TYPE.REMOVE_INVISIBLE_ITEMS = Get information on visible items only. STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS = Compress invisible items. You can replace it with a placeholder. STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS = Compress invisible groups. <ko> STATUS_TYPE.NOT_REMOVE = 모든 아이템들의 정보를 가져온다. STATUS_TYPE.REMOVE_INVISIBLE_ITEMS = 보이는 아이템들의 정보만 가져온다. STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS = 안보이는 아이템들을 압축한다. placeholder로 대체가 가능하다. STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS = 안보이는 그룹을 압축한다.</ko>\n   * @param - Whether to include items corresponding to placeholders. <ko>placeholder에 해당하는 아이템들을 포함할지 여부.</ko>\n   */\n  __proto.getStatus = function (type, includePlaceholders) {\n    return {\n      containerManager: this.containerManager.getStatus(),\n      itemRenderer: this.itemRenderer.getStatus(),\n      groupManager: this.groupManager.getGroupStatus(type, includePlaceholders),\n      scrollManager: this.scrollManager.getStatus()\n    };\n  };\n  /**\n   * You can set placeholders to restore status or wait for items to be added.\n   * @ko status 복구 또는 아이템 추가 대기를 위한 placeholder를 설정할 수 있다.\n   * @param - The placeholder status. <ko>placeholder의 status</ko>\n   */\n  __proto.setPlaceholder = function (info) {\n    this.groupManager.setPlaceholder(info);\n    return this;\n  };\n  /**\n   * You can set placeholders to restore status or wait for items to be added.\n   * @ko status 복구 또는 아이템 추가 대기를 위한 placeholder를 설정할 수 있다.\n   * @param - The placeholder status. <ko>placeholder의 status</ko>\n   */\n  __proto.setLoading = function (info) {\n    this.groupManager.setLoading(info);\n    return this;\n  };\n  /**\n   * Add the placeholder at the end.\n   * @ko placeholder들을 마지막에 추가한다.\n   * @param - Items that correspond to placeholders. If it is a number, it duplicates the number of copies. <ko>placeholder에 해당하는 아이템들. 숫자면 갯수만큼 복제를 한다.</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   */\n  __proto.appendPlaceholders = function (items, groupKey) {\n    var _this = this;\n    var result = this.groupManager.appendPlaceholders(items, groupKey);\n    this._syncGroups(true);\n    return __assign(__assign({}, result), {\n      remove: function () {\n        _this.removePlaceholders({\n          groupKey: result.group.groupKey\n        });\n      }\n    });\n  };\n  /**\n   * Add the placeholder at the start.\n   * @ko placeholder들을 처음에 추가한다.\n   * @param - Items that correspond to placeholders. If it is a number, it duplicates the number of copies. <ko>placeholder에 해당하는 아이템들. 숫자면 갯수만큼 복제를 한다.</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   */\n  __proto.prependPlaceholders = function (items, groupKey) {\n    var _this = this;\n    var result = this.groupManager.prependPlaceholders(items, groupKey);\n    this._syncGroups(true);\n    return __assign(__assign({}, result), {\n      remove: function () {\n        _this.removePlaceholders({\n          groupKey: result.group.groupKey\n        });\n      }\n    });\n  };\n  /**\n   * Remove placeholders\n   * @ko placeholder들을 삭제한다.\n   * @param type - Remove the placeholders corresponding to the groupkey. When \"start\" or \"end\", remove all placeholders in that direction. <ko>groupkey에 해당하는 placeholder들을 삭제한다. \"start\" 또는 \"end\" 일 때 해당 방향의 모든 placeholder들을 삭제한다.</ko>\n   */\n  __proto.removePlaceholders = function (type) {\n    this.groupManager.removePlaceholders(type);\n    this._syncGroups(true);\n  };\n  /**\n   * Sets the status of the InfiniteGrid module with the information returned through a call to the getStatus() method.\n   * @ko getStatus() 메서드가 저장한 정보로 InfiniteGrid 모듈의 상태를 설정한다.\n   * @param - status object of the InfiniteGrid module. <ko>InfiniteGrid 모듈의 status 객체.</ko>\n   * @param - Whether the first rendering has already been done. <ko>첫 렌더링이 이미 되어있는지 여부.</ko>\n   */\n  __proto.setStatus = function (status, useFirstRender) {\n    this.itemRenderer.setStatus(status.itemRenderer);\n    this.containerManager.setStatus(status.containerManager);\n    this.scrollManager.setStatus(status.scrollManager);\n    var groupManager = this.groupManager;\n    var prevInlineSize = this.containerManager.getInlineSize();\n    groupManager.setGroupStatus(status.groupManager);\n    this._syncInfinite();\n    this.infinite.setCursors(groupManager.getStartCursor(), groupManager.getEndCursor());\n    this._getRenderer().updateKey();\n    var state = {\n      isResize: this.containerManager.getInlineSize() !== prevInlineSize,\n      isRestore: true\n    };\n    if (useFirstRender) {\n      this._syncItems(state);\n    } else {\n      this._update(state);\n    }\n    return this;\n  };\n  /**\n   * Removes the group corresponding to index.\n   * @ko index에 해당하는 그룹을 제거 한다.\n   */\n  __proto.removeGroupByIndex = function (index) {\n    var nextGroups = this.getGroups();\n    return this.removeGroupByKey(nextGroups[index].groupKey);\n  };\n  /**\n   * Removes the group corresponding to key.\n   * @ko key에 해당하는 그룹을 제거 한다.\n   */\n  __proto.removeGroupByKey = function (key) {\n    var nextItemInfos = this.getItems();\n    var firstIndex = findIndex(nextItemInfos, function (item) {\n      return item.groupKey === key;\n    });\n    var lastIndex = findLastIndex(nextItemInfos, function (item) {\n      return item.groupKey === key;\n    });\n    if (firstIndex === -1) {\n      return this;\n    }\n    nextItemInfos.splice(firstIndex, lastIndex - firstIndex + 1);\n    return this.syncItems(nextItemInfos);\n  };\n  /**\n   * Removes the item corresponding to index.\n   * @ko index에 해당하는 아이템을 제거 한다.\n   */\n  __proto.removeByIndex = function (index) {\n    var nextItemInfos = this.getItems(true);\n    nextItemInfos.splice(index, 1);\n    return this.syncItems(nextItemInfos);\n  };\n  /**\n   * Removes the item corresponding to key.\n   * @ko key에 해당하는 아이템을 제거 한다.\n   */\n  __proto.removeByKey = function (key) {\n    var nextItemInfos = this.getItems(true);\n    var index = findIndex(nextItemInfos, function (item) {\n      return item.key === key;\n    });\n    return this.removeByIndex(index);\n  };\n  /**\n   * Update the size of the items and render them.\n   * @ko 아이템들의 사이즈를 업데이트하고 렌더링을 한다.\n   * @param - Items to be updated. <ko>업데이트할 아이템들.</ko>\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  __proto.updateItems = function (items, options) {\n    if (options === void 0) {\n      options = {};\n    }\n    this.groupManager.updateItems(items, options);\n    return this;\n  };\n  /**\n   * Return all items of InfiniteGrid.\n   * @ko InfiniteGrid의 모든 아이템들을 반환한다.\n   * @param - Whether to include items corresponding to placeholders. <ko>placeholder에 해당하는 아이템들을 포함할지 여부.</ko>\n   */\n  __proto.getItems = function (includePlaceholders) {\n    return this.groupManager.getGroupItems(includePlaceholders);\n  };\n  /**\n   * Return visible items of InfiniteGrid.\n   * @ko InfiniteGrid의 보이는 아이템들을 반환한다.\n   * @param - Whether to include items corresponding to placeholders. <ko>placeholder에 해당하는 아이템들을 포함할지 여부.</ko>\n   */\n  __proto.getVisibleItems = function (includePlaceholders) {\n    return this.groupManager.getVisibleItems(includePlaceholders);\n  };\n  /**\n   * Return rendering items of InfiniteGrid.\n   * @ko InfiniteGrid의 렌더링 아이템들을 반환한다.\n   */\n  __proto.getRenderingItems = function () {\n    return this.groupManager.getRenderingItems();\n  };\n  /**\n   * Return all groups of InfiniteGrid.\n   * @ko InfiniteGrid의 모든 그룹들을 반환한다.\n   * @param - Whether to include groups corresponding to placeholders. <ko>placeholder에 해당하는 그룹들을 포함할지 여부.</ko>\n   */\n  __proto.getGroups = function (includePlaceholders) {\n    return this.groupManager.getGroups(includePlaceholders);\n  };\n  /**\n   * Return visible groups of InfiniteGrid.\n   * @ko InfiniteGrid의 보이는 그룹들을 반환한다.\n   * @param - Whether to include groups corresponding to placeholders. <ko>placeholder에 해당하는 그룹들을 포함할지 여부.</ko>\n   */\n  __proto.getVisibleGroups = function (includePlaceholders) {\n    return this.groupManager.getVisibleGroups(includePlaceholders);\n  };\n  /**\n   * Set to wait to request data.\n   * @ko 데이터를 요청하기 위해 대기 상태로 설정한다.\n   * @param direction - direction in which data will be added. <ko>데이터를 추가하기 위한 방향.</ko>\n   */\n  __proto.wait = function (direction) {\n    if (direction === void 0) {\n      direction = DIRECTION.END;\n    }\n    this._waitType = direction;\n    this._checkStartLoading(direction);\n  };\n  /**\n   * When the data request is complete, it is set to ready state.\n   * @ko 데이터 요청이 끝났다면 준비 상태로 설정한다.\n   * @param - <ko>데이터가 존재하지 않으면 loading bar를 즉시 제거 한다.</ko>\n   */\n  __proto.ready = function (hasNoData) {\n    this._waitType = \"\";\n    if (hasNoData) {\n      this.groupManager.waitEndLoading();\n      if (this.groupManager.endLoading()) {\n        this._update();\n      }\n    }\n  };\n  /**\n   * Returns whether it is set to wait to request data.\n   * @ko 데이터를 요청하기 위해 대기 상태로 설정되어 있는지 여부를 반환한다.\n   */\n  __proto.isWait = function () {\n    return !!this._waitType;\n  };\n  /**\n   * Releases the instnace and events and returns the CSS of the container and elements.\n   * @ko 인스턴스와 이벤트를 해제하고 컨테이너와 엘리먼트들의 CSS를 되돌린다.\n   */\n  __proto.destroy = function () {\n    this.off();\n    this._getRenderer().destroy();\n    this.containerManager.destroy();\n    this.groupManager.destroy();\n    this.scrollManager.destroy();\n    this.infinite.destroy();\n  };\n  __proto._getRenderer = function () {\n    return this.options.renderer;\n  };\n  __proto._getRendererItems = function () {\n    return this.getRenderingItems().map(function (item) {\n      return {\n        element: item.element,\n        key: \"\".concat(item.type, \"_\").concat(item.key),\n        orgItem: item\n      };\n    });\n  };\n  __proto._syncItems = function (state) {\n    this._getRenderer().syncItems(this._getRendererItems(), state);\n  };\n  __proto._render = function (state) {\n    this._getRenderer().render(this._getRendererItems(), state);\n  };\n  __proto._update = function (state) {\n    if (state === void 0) {\n      state = {};\n    }\n    this._getRenderer().update(state);\n  };\n  __proto._resizeScroll = function () {\n    var scrollManager = this.scrollManager;\n    scrollManager.resize();\n    this.infinite.setSize(scrollManager.getContentSize());\n  };\n  __proto._syncGroups = function (isUpdate) {\n    var infinite = this.infinite;\n    var scrollManager = this.scrollManager;\n    if (!scrollManager.getContentSize()) {\n      this._resizeScroll();\n    }\n    this._syncInfinite();\n    this.groupManager.setCursors(infinite.getStartCursor(), infinite.getEndCursor());\n    if (isUpdate) {\n      this._update();\n    } else {\n      this._render();\n    }\n  };\n  __proto._syncInfinite = function () {\n    this.infinite.syncItems(this.getGroups(true).map(function (_a) {\n      var groupKey = _a.groupKey,\n        grid = _a.grid,\n        type = _a.type;\n      var outlines = grid.getOutlines();\n      return {\n        key: groupKey,\n        isVirtual: type === GROUP_TYPE.VIRTUAL,\n        startOutline: outlines.start,\n        endOutline: outlines.end,\n        parts: grid.getItems().map(function (item) {\n          return {\n            key: item.key,\n            pos: item.computedContentPos,\n            size: item.computedContentSize\n          };\n        })\n      };\n    }));\n  };\n  __proto._scroll = function () {\n    this.infinite.scroll(this.scrollManager.getRelativeScrollPos());\n  };\n  __proto._onRequestInsert = function (direction, eventType, e) {\n    var _this = this;\n    if (this._waitType) {\n      this._checkStartLoading(this._waitType);\n      return;\n    }\n    this.trigger(new ComponentEvent(eventType, {\n      groupKey: e.key,\n      nextGroupKey: e.nextKey,\n      nextGroupKeys: e.nextKeys || [],\n      isVirtual: e.isVirtual,\n      wait: function () {\n        _this.wait(direction);\n      },\n      ready: function (hasNoData) {\n        _this.ready(hasNoData);\n      }\n    }));\n  };\n  __proto._renderItems = function (options, isTrusted) {\n    if (options === void 0) {\n      options = {};\n    }\n    if (!isTrusted && options.useResize) {\n      this.containerManager.resize();\n    }\n    this._resizeScroll();\n    if (!this.getRenderingItems().length) {\n      var children = toArray(this.getContainerElement().children);\n      if (children.length > 0) {\n        // no items, but has children\n        this.groupManager.syncItems(convertInsertedItems(children));\n        this._syncInfinite();\n        this.setCursors(0, 0, true);\n        this._getRenderer().updated();\n      } else {\n        this.infinite.scroll(0);\n      }\n      return this;\n    }\n    if (!this.getVisibleGroups(true).length) {\n      this.setCursors(0, 0);\n    } else {\n      this.groupManager.renderItems(options);\n    }\n    return this;\n  };\n  __proto._checkStartLoading = function (direction) {\n    var groupManager = this.groupManager;\n    var infinite = this.infinite;\n    if (!groupManager.getLoadingType() && infinite.isLoading(direction) && groupManager.startLoading(direction) && groupManager.hasLoadingItem()) {\n      this._update();\n    }\n  };\n  __proto._checkEndLoading = function () {\n    var groupManager = this.groupManager;\n    var loadingType = this.groupManager.getLoadingType();\n    if (loadingType && (!this._waitType || !this.infinite.isLoading(loadingType)) && groupManager.waitEndLoading() && groupManager.hasLoadingItem()) {\n      this._update();\n    }\n  };\n  var InfiniteGrid_1;\n  InfiniteGrid.defaultOptions = __assign(__assign({}, DEFAULT_GRID_OPTIONS), {\n    container: false,\n    containerTag: \"div\",\n    renderer: null,\n    threshold: 100,\n    useRecycle: true,\n    scrollContainer: null,\n    appliedItemChecker: function () {\n      return false;\n    }\n  });\n  InfiniteGrid.propertyTypes = INFINITEGRID_PROPERTY_TYPES;\n  InfiniteGrid = InfiniteGrid_1 = __decorate([InfiniteGridGetterSetter], InfiniteGrid);\n  return InfiniteGrid;\n}(Component);\n\n/**\n * MasonryInfiniteGrid is a grid that stacks items with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new item.\n * @ko MasonryInfiniteGrid는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 아이템을 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 아이템 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {MasonryInfiniteGridOptions} options - The option object of the MasonryInfiniteGrid module <ko>MasonryInfiniteGrid 모듈의 옵션 객체</ko>\n */\nvar MasonryInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(MasonryInfiniteGrid, _super);\n  function MasonryInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  MasonryInfiniteGrid.propertyTypes = __assign(__assign({}, InfiniteGrid.propertyTypes), MasonryGrid.propertyTypes);\n  MasonryInfiniteGrid.defaultOptions = __assign(__assign(__assign({}, InfiniteGrid.defaultOptions), MasonryGrid.defaultOptions), {\n    gridConstructor: MasonryGrid,\n    appliedItemChecker: function (item, grid) {\n      var column = parseFloat(item.attributes.column) || 0;\n      return column >= grid.outlineLength;\n    }\n  });\n  MasonryInfiniteGrid = __decorate([InfiniteGridGetterSetter], MasonryInfiniteGrid);\n  return MasonryInfiniteGrid;\n}(InfiniteGrid);\n\n/**\n * 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedInfiniteGrid is a grid that the item is filled up on the basis of a line given a size.\n * If 'data-grid-inline-offset' or 'data-grid-content-offset' are set for item element, the ratio is maintained except for the offset value.\n * If 'data-grid-maintained-target' is set for an element whose ratio is to be maintained, the item is rendered while maintaining the ratio of the element.\n * @ko 'justified'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. JustifiedInfiniteGrid는 용어의 의미대로 너비가 주어진 사이즈를 기준으로 아이템가 가득 차도록 배치하는 Grid다.\n * 아이템 엘리먼트에 'data-grid-inline-offset' 또는 'data-grid-content-offset'를 설정하면 offset 값을 제외하고 비율을 유지한다.\n * 비율을 유지하고 싶은 엘리먼트에 'data-grid-maintained-target'을 설정한다면 해당 엘리먼트의 비율을 유지하면서 아이템이 렌더링이 된다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {JustifiedInfiniteGridOptions} options - The option object of the JustifiedInfiniteGrid module <ko>JustifiedInfiniteGrid 모듈의 옵션 객체</ko>\n */\nvar JustifiedInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(JustifiedInfiniteGrid, _super);\n  function JustifiedInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  JustifiedInfiniteGrid.propertyTypes = __assign(__assign({}, InfiniteGrid.propertyTypes), JustifiedGrid.propertyTypes);\n  JustifiedInfiniteGrid.defaultOptions = __assign(__assign(__assign({}, InfiniteGrid.defaultOptions), JustifiedGrid.defaultOptions), {\n    gridConstructor: JustifiedGrid\n  });\n  JustifiedInfiniteGrid = __decorate([InfiniteGridGetterSetter], JustifiedInfiniteGrid);\n  return JustifiedInfiniteGrid;\n}(InfiniteGrid);\n\n/**\n * 'Frame' is a printing term with the meaning that 'it fits in one row wide'. FrameInfiniteGrid is a grid that the item is filled up on the basis of a line given a size.\n * @ko 'Frame'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. FrameInfiniteGrid는 용어의 의미대로 너비가 주어진 사이즈를 기준으로 아이템이 가득 차도록 배치하는 Grid다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {FrameInfiniteGridOptions} options - The option object of the FrameInfiniteGrid module <ko>FrameGrid 모듈의 옵션 객체</ko>\n */\nvar FrameInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(FrameInfiniteGrid, _super);\n  function FrameInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  FrameInfiniteGrid.propertyTypes = __assign(__assign({}, InfiniteGrid.propertyTypes), FrameGrid.propertyTypes);\n  FrameInfiniteGrid.defaultOptions = __assign(__assign(__assign({}, InfiniteGrid.defaultOptions), FrameGrid.defaultOptions), {\n    gridConstructor: FrameGrid\n  });\n  FrameInfiniteGrid = __decorate([InfiniteGridGetterSetter], FrameInfiniteGrid);\n  return FrameInfiniteGrid;\n}(InfiniteGrid);\n\n/**\n * The PackingInfiniteGrid is a grid that shows the important items bigger without sacrificing the weight of the items.\n * Rows and columns are separated so that items are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * If `sizeWeight` is higher than `ratioWeight`, the size of items is preserved as much as possible.\n * Conversely, if `ratioWeight` is higher than `sizeWeight`, the ratio of items is preserved as much as possible.\n * @ko PackingInfiniteGrid는 아이템의 본래 크기에 따른 비중을 해치지 않으면서 중요한 카드는 더 크게 보여 주는 레이아웃이다.\n * 행과 열이 구분돼 아이템을 정돈되게 배치하는 대신 가로세로 일정 공간 내에서 동적으로 아이템을 배치한다.\n * `sizeWeight`가 `ratioWeight`보다 높으면 아이템들의 size가 최대한 보존이 된다.\n * 반대로 `ratioWeight`가 `sizeWeight`보다 높으면 아이템들의 비율이 최대한 보존이 된다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {PackingInfiniteGridOptions} options - The option object of the PackingInfiniteGrid module <ko>PackingInfiniteGrid 모듈의 옵션 객체</ko>\n */\nvar PackingInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(PackingInfiniteGrid, _super);\n  function PackingInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PackingInfiniteGrid.propertyTypes = __assign(__assign({}, InfiniteGrid.propertyTypes), PackingGrid.propertyTypes);\n  PackingInfiniteGrid.defaultOptions = __assign(__assign(__assign({}, InfiniteGrid.defaultOptions), PackingGrid.defaultOptions), {\n    gridConstructor: PackingGrid\n  });\n  PackingInfiniteGrid = __decorate([InfiniteGridGetterSetter], PackingInfiniteGrid);\n  return PackingInfiniteGrid;\n}(InfiniteGrid);\nexport default InfiniteGrid;\nexport { CONTAINER_CLASS_NAME, DIRECTION, FrameInfiniteGrid, GROUP_TYPE, IGNORE_PROPERITES_MAP, INFINITEGRID_EVENTS, INFINITEGRID_METHODS, INFINITEGRID_PROPERTY_TYPES, INVISIBLE_POS, IS_IOS, ITEM_INFO_PROPERTIES, ITEM_TYPE, InfiniteGridItem, JustifiedInfiniteGrid, MasonryInfiniteGrid, PackingInfiniteGrid, Renderer, STATUS_TYPE, getRenderingItems, mountRenderingItems, withInfiniteGridMethods };","map":{"version":3,"names":["ua","window","navigator","userAgent","IS_IOS","test","CONTAINER_CLASS_NAME","IGNORE_PROPERITES_MAP","renderOnPropertyChange","useFit","autoResize","INFINITEGRID_PROPERTY_TYPES","__assign","GRID_PROPERTY_TYPES","DIRECTION","START","END","NONE","INFINITEGRID_EVENTS","CHANGE_SCROLL","REQUEST_APPEND","REQUEST_PREPEND","RENDER_COMPLETE","CONTENT_ERROR","ITEM_INFO_PROPERTIES","type","groupKey","key","element","html","data","inserted","attributes","INFINITEGRID_METHODS","GROUP_TYPE","ITEM_TYPE","STATUS_TYPE","INVISIBLE_POS","InfiniteGridItem","_super","__extends","horizontal","itemStatus","_this","call","NORMAL","cssRect","top","left","VIRTUAL","rect","width","height","mountState","MOUNT_STATE","UNMOUNTED","orgRect","__proto","prototype","getVirtualStatus","getMinimizedStatus","status","GridItem","LOADING_GROUP_KEY","LOADING_ITEM_KEY","LoadingGrid","apply","arguments","isWaitEnd","initialDisplay","getLoadingItem","items","startLoading","style","display","removeProperty","endLoading","setLoadingItem","item","loadingItem","options","LOADING","name","applyGrid","direction","outline","length","start","end","nextOutline","__spreadArray","offset","contentSize","getContentGap","cssInlinePos","getContainerInlineSize","inlineSize","maxPos","Math","max","cssContentPos","map","pos","minPos","min","Grid","isWindow","el","isNumber","val","isString","isObject","flat","arr","reduce","prev","cur","splitOptions","gridOptions","otherOptions","__rest","splitGridOptions","nextOptions","defaultOptions","value","categorize","groups","groupKeys","registeredGroupKeys","filter","forEach","_a","generatedGroupKey","isContinuousGroupKey","i","makeKey","group","push","getNextCursors","prevKeys","nextKeys","prevStartCursor","prevEndCursor","result","diff","nextStartCursor","nextEndCursor","maintained","prevIndex","nextIndex","startCursor","endCursor","splitVirtualGroups","nextGroups","virtualGroups","index","findIndex","endMaintainedIndex","nextGroup","endIndex","slice","findLastIndex","startMaintainedIndex","startIndex","getFirstRenderingItems","nextItems","getRenderingItemsByStatus","groupManagerStatus","usePlaceholder","prevGroups","startVirtualGroups","endVirtualGroups","cursors","nextVisibleItems","mountRenderingItems","grid","useLoading","useFirstRender","setPlaceholder","setLoading","setStatus","syncItems","getGroups","setCursors","getRenderingItems","visibleItems","groupManager","InfiniteGridGetterSetter","component","propertyTypes","enumerable","configurable","get","set","prevValue","Object","defineProperty","registeredKeys","prefix","concat","convertHTMLtoElement","dummy","document","createElement","innerHTML","toArray","children","convertInsertedItems","insertedItems","outerHTML","nodes","array","callback","getItemInfo","info","nextInfo","isFlatOutline","every","range","flatGroups","getItems","filterVirtuals","includePlaceholders","withInfiniteGridMethods","withClassMethods","GroupManager","container","groupItems","itemKeys","_placeholder","_loadingGrid","externalContainerManager","containerManager","gap","_mainGrid","_makeGrid","shouldRender","_checkShouldRender","scheduleRender","getItemByKey","getGroupItems","getVisibleItems","hasPlaceholder","hasVisibleVirtualGroups","getVisibleGroups","some","hasLoadingItem","_getLoadingItem","updateItems","placeholder","_updatePlaceholder","getLoadingType","_getRenderingItems","waitEndLoading","prevType","loading","getComputedOutlineLength","getComputedOutlineSize","renderingGroups","loadingGrid","unshift","_getLoadingGroup","reverse","appliedItemChecker","outlineLength","outlineSize","itemRenderer","passedItems","gridItems","isVirtual","appliedItems","UNCHECKED","updateItem","gridOutlines","_applyVirtualGrid","setOutlines","passed","_b","getOutlines","nextItemInfos","prevItemKeys","_syncItemInfos","prevGroupKeys","nextManagerGroups","_splitVirtualGroups","_mergeVirtualGroups","_c","setItems","renderItems","_registerGroups","useResize","updateState","UPDATE_STATE","NEED_UPDATE","getStartCursor","getEndCursor","getGroupStatus","orgStartCursor","orgEndCursor","orgGroups","startGroup","endGroup","isMinimizeItems","MINIMIZE_INVISIBLE_ITEMS","isMinimizeGroups","MINIMIZE_INVISIBLE_GROUPS","REMOVE_INVISIBLE_GROUPS","orgIndex","orgGroup","indexOf","lastIndexOf","groupStatus","isOutsideCursor","isVirtualItems","isVirtualGroup","outlines","totalItems","itemStartCursor","itemEndCursor","orgCursors","itemCursors","startGroupKey","endGroupKey","fitOutlines","startOutline","outlineOffset","point","contentPos","setGroupStatus","appendPlaceholders","insertPlaceholders","prependPlaceholders","removePlaceholders","splice","groupKey_1","infos","Array","isArray","shouldRerenderItems","isRerender","_updateItems","updateEqualSizeItems","_getGroupItems","GridConstructor","gridConstructor","prevOptions","PROPERTY_TYPE","RENDER_PROPERTY","prevOutlines","prevOutline","nextItemKeys","prevItem","nextGroupKeys","prevGroup","containerElement","useResizeObserver","observeChildren","externalItemRenderer","PROPERTY","__decorate","GetterSetter","Infinite","size","threshold","useRecycle","defaultDirection","scroll","scrollPos","isDirectionEnd","trigger","undefined","nextCursor","endScrollPos","startEdgePos","endEdgePos","endOutline","visibles","startPos","endPos","hasStartItems","hasEndItems","isStart","isEnd","hasRealItem","hasVirtualItems","isStartVirtual","isEndVirtual","realItemIndex","endVirtualItemIndex","nextKey","startVirtualItemIndex","_requestVirtualItems","totalVisibleItems","totalVisibleLength","visibleLength","startKey_1","endKey_1","lastItem","setSize","isLoading","firstItem","prevItems","isChange","prevVisibleItems","visibleResult","added","removed","changed","getSize","getItemPartByKey","partKey","itemPart","parts","part","getScrollSize","getVisibleArea","getRenderedVisibleItems","visibleItem","itemPos","rendered","destroy","off","Component","Renderer","rendererKey","_updateTimer","_state","_isItemChanged","updateKey","Date","now","setContainer","render","state","update","clearTimeout","setTimeout","updated","nextElements","diffResult","_diffResult","isChanged","isItemChanged","list","elements","renderKey","VanillaRenderer","prevList","ordered","diffList","removeChild","insertBefore","VanillaGridRenderer","orgItem","ScrollManager","wrapper","prevScrollPos","scrollOffset","_isScrollIssue","_onCheck","getScrollPos","nextScrollPos","getOrgScrollPos","setScrollPos","ComponentEvent","relativeScrollPos","getRelativeScrollPos","containerTag","scrollContainer","_init","getWrapper","getContainer","getScrollContainer","getScrollOffset","getContentSize","eventTarget","prop","documentElement","body","scrollTo","getStatus","x","y","scrollLeft","scrollTop","scrollBy","resize","isBody","scrollContainerRect","getBoundingClientRect","containerRect","innerWidth","innerHeight","offsetWidth","offsetHeight","removeEventListener","_isCreateElement","fragment_1","createDocumentFragment","childNodes","childNode","appendChild","cssText","_orgCSSText","containerOption","scrollContainerOption","containerCSSText","findTarget","position","className","overflowX","overflowY","addEventListener","InfiniteGrid","_waitType","_onScroll","_scroll","_onChange","e","_onRendererUpdated","renderedItems","gridItem","_checkEndLoading","addedItems","unobserveChildren","isRestore","isResize","_onRenderComplete","mounted","_onResize","isResizeContainer","_renderItems","updatedItems","getUpdatedItems","childEntries","_onRequestAppend","_onRequestInsert","_onRequestPrepend","_onContentError","target","remove","removeByKey","infinite","scrollManager","prevScrollSize","prevContainerSize","prevVisibleArea","_syncInfinite","prevPart","nextPart","nextItem","prevPos","nextPos","prevStartPos","prevEndPos","nextStartPos","nextEndPos","nextScrollSize","nextContainerSize","endOffset","nextScollPos","completeMounted","isUpdate","_update","constructor","renderer","on","_render","attributePrefix","useTransform","percentage","isConstantSize","isEqualSize","resizeDebounce","maxResizeDebounce","useRoundedSize","wrapperElement","querySelector","ContainerManager","ItemRenderer","getWrapperElement","getScrollContainerElement","getContainerElement","_syncGroups","_syncItems","append","insert","prepend","itemInfos","insertByGroupIndex","groupIndex","nextGroupInfos","rightGroup","rightGroupKey","rightItemIndex","prevInlineSize","getInlineSize","_getRenderer","removeGroupByIndex","removeGroupByKey","firstIndex","lastIndex","removeByIndex","wait","_checkStartLoading","ready","hasNoData","isWait","_getRendererItems","_resizeScroll","computedContentPos","computedContentSize","eventType","nextGroupKey","isTrusted","loadingType","DEFAULT_GRID_OPTIONS","InfiniteGrid_1","MasonryInfiniteGrid","MasonryGrid","column","parseFloat","JustifiedInfiniteGrid","JustifiedGrid","FrameInfiniteGrid","FrameGrid","PackingInfiniteGrid","PackingGrid"],"sources":["/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/consts.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/InfiniteGridItem.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/LoadingGrid.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/utils.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/GroupManager.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/Infinite.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/Renderer/Renderer.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/Renderer/VanillaRenderer.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/Renderer/VanillaGridRenderer.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/ScrollManager.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/InfiniteGrid.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/grids/MasonryInfiniteGrid.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/grids/JustifiedInfiniteGrid.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/grids/FrameInfiniteGrid.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/infinitegrid/src/grids/PackingInfiniteGrid.ts"],"sourcesContent":["import { GRID_PROPERTY_TYPES } from \"@egjs/grid\";\nimport { InfiniteGridItemInfo } from \"./types\";\n\nconst ua = typeof window !== \"undefined\" ? window.navigator.userAgent : \"\";\n\nexport const IS_IOS = /iPhone|iPad/.test(ua);\nexport const CONTAINER_CLASS_NAME = \"infinitegrid-container\";\nexport const IGNORE_PROPERITES_MAP = {\n  renderOnPropertyChange: true,\n  useFit: true,\n  autoResize: true,\n} as const;\n\n\nexport const INFINITEGRID_PROPERTY_TYPES = {\n  ...GRID_PROPERTY_TYPES,\n};\n\nexport const DIRECTION = {\n  START: \"start\",\n  END: \"end\",\n  NONE: \"\",\n} as const;\n\nexport const INFINITEGRID_EVENTS = {\n  CHANGE_SCROLL: \"changeScroll\",\n  REQUEST_APPEND: \"requestAppend\",\n  REQUEST_PREPEND: \"requestPrepend\",\n  RENDER_COMPLETE: \"renderComplete\",\n  CONTENT_ERROR: \"contentError\",\n} as const;\n\nexport const ITEM_INFO_PROPERTIES: Record<keyof InfiniteGridItemInfo, true> = {\n  type: true,\n  groupKey: true,\n  key: true,\n  element: true,\n  html: true,\n  data: true,\n  inserted: true,\n  attributes: true,\n};\n\n\nexport const INFINITEGRID_METHODS = [\n  \"insertByGroupIndex\",\n  \"updateItems\",\n  \"getItems\",\n  \"getVisibleItems\",\n  \"getGroups\",\n  \"getVisibleGroups\",\n  \"renderItems\",\n  \"getContainerElement\",\n  \"getScrollContainerElement\",\n  \"getWrapperElement\",\n  \"setStatus\",\n  \"getStatus\",\n  \"removePlaceholders\",\n  \"prependPlaceholders\",\n  \"appendPlaceholders\",\n  \"getStartCursor\",\n  \"getEndCursor\",\n  \"setCursors\",\n] as const;\n\n\nexport enum GROUP_TYPE {\n  NORMAL = 0,\n  VIRTUAL = 1,\n  LOADING = 2,\n}\n\nexport enum ITEM_TYPE {\n  NORMAL = 0,\n  VIRTUAL = 1,\n  LOADING = 2,\n}\n\nexport enum STATUS_TYPE {\n  // does not remove anything.\n  NOT_REMOVE = 0,\n  // Minimize information on invisible items\n  MINIMIZE_INVISIBLE_ITEMS = 1,\n  // Minimize information on invisible groups\n  MINIMIZE_INVISIBLE_GROUPS = 2,\n  // remove invisible groups\n  REMOVE_INVISIBLE_GROUPS = 3,\n}\n\n\nexport const INVISIBLE_POS = -9999;\n","import { GridItem, GridItemStatus, MOUNT_STATE } from \"@egjs/grid\";\nimport { INVISIBLE_POS, ITEM_TYPE } from \"./consts\";\nimport { InfiniteGridItemInfo } from \"./types\";\n\n\nexport interface InfiniteGridItemStatus extends GridItemStatus {\n  type?: ITEM_TYPE;\n  groupKey?: string | number;\n  key?: string | number;\n  html?: string;\n}\n\n/**\n * @extends Grid.GridItem\n */\nexport class InfiniteGridItem extends GridItem implements Required<InfiniteGridItemInfo> {\n  public groupKey: string | number;\n  public inserted: boolean;\n  public readonly html: string;\n  constructor(horizontal: boolean, itemStatus?: Partial<InfiniteGridItemStatus>) {\n    super(horizontal, {\n      html: \"\",\n      type: ITEM_TYPE.NORMAL,\n      cssRect: { top: INVISIBLE_POS, left: INVISIBLE_POS },\n      ...itemStatus,\n    } as GridItemStatus);\n\n    if (this.type === ITEM_TYPE.VIRTUAL) {\n      if (this.rect.width || this.rect.height) {\n        this.mountState = MOUNT_STATE.UNMOUNTED;\n      }\n      const orgRect = this.orgRect;\n      const rect = this.rect;\n      const cssRect = this.cssRect;\n\n      if (cssRect.width) {\n        rect.width = cssRect.width;\n      } else if (orgRect.width) {\n        rect.width = orgRect.width;\n      }\n      if (cssRect.height) {\n        rect.height = cssRect.height;\n      } else if (orgRect.height) {\n        rect.height = orgRect.height;\n      }\n    }\n  }\n  public getVirtualStatus(): Partial<InfiniteGridItemStatus> {\n    return {\n      type: ITEM_TYPE.VIRTUAL,\n      groupKey: this.groupKey,\n      key: this.key,\n      orgRect: this.orgRect,\n      rect: this.rect,\n      cssRect: this.cssRect,\n      attributes: this.attributes,\n    };\n  }\n  public getMinimizedStatus(): Partial<InfiniteGridItemStatus> {\n    const status: Partial<InfiniteGridItemStatus> = {\n      ...super.getMinimizedStatus(),\n      type: ITEM_TYPE.NORMAL,\n      groupKey: this.groupKey,\n    };\n    if (this.html) {\n      status.html = this.html;\n    }\n    return status;\n  }\n}\n\nexport interface InfiniteGridItem extends Required<InfiniteGridItemStatus> {}\n","import Grid, { GridItem, GridOutlines } from \"@egjs/grid\";\nimport { ITEM_TYPE } from \"./consts\";\nimport { InfiniteGridItem, InfiniteGridItemStatus } from \"./InfiniteGridItem\";\n\nexport const LOADING_GROUP_KEY = \"__INFINITEGRID__LOADING_GRID\";\nexport const LOADING_ITEM_KEY = \"__INFINITEGRID__LOADING_ITEM\";\n\nexport class LoadingGrid extends Grid {\n  public type: \"start\" | \"end\" | \"\" = \"\";\n  public isWaitEnd = false;\n  public initialDisplay: string | null = null;\n  public getLoadingItem(): InfiniteGridItem | null {\n    return this.items[0] as InfiniteGridItem || null;\n  }\n  public startLoading() {\n    const element = this.items[0].element;\n\n    if (element) {\n      if (this.initialDisplay != null) {\n        this.initialDisplay = element.style.display || \"\";\n      } else if (this.initialDisplay) {\n        element.style.display = this.initialDisplay;\n      } else {\n        element.style.removeProperty(\"display\");\n      }\n    }\n  }\n  public endLoading() {\n    if (this.type) {\n      const element = this.items[0].element;\n\n      if (element) {\n        element.style.display = \"none\";\n      }\n    }\n  }\n  public setLoadingItem(item: Partial<InfiniteGridItemStatus> | null) {\n    if (item) {\n      const loadingItem = this.getLoadingItem();\n\n      if (!loadingItem) {\n        this.items = [new InfiniteGridItem(this.options.horizontal, {\n          ...item,\n          type: ITEM_TYPE.LOADING,\n          key: LOADING_ITEM_KEY,\n        })];\n      } else {\n        for (const name in item) {\n          loadingItem[name] = item[name];\n        }\n      }\n    } else {\n      this.items = [];\n    }\n  }\n  public applyGrid(items: GridItem[], direction: \"start\" | \"end\", outline: number[]): GridOutlines {\n    if (!items.length) {\n      return {\n        start: outline,\n        end: outline,\n      };\n    }\n    const nextOutline = outline.length ? [...outline] : [0];\n    const item = items[0];\n    const offset = item.contentSize + this.getContentGap();\n\n    item.cssInlinePos = this.getContainerInlineSize() / 2 - item.inlineSize / 2;\n\n    if (direction === \"end\") {\n      const maxPos = Math.max(...nextOutline);\n\n      item.cssContentPos = maxPos;\n\n      return {\n        start: nextOutline,\n        end: nextOutline.map((pos) => pos + offset),\n      };\n    } else {\n      const minPos = Math.min(...nextOutline);\n\n      item.cssContentPos = minPos - offset;\n\n      return {\n        start: nextOutline.map((pos) => pos - offset),\n        end: nextOutline,\n      };\n    }\n  }\n}\n","import { withClassMethods } from \"@cfcs/core\";\nimport Grid, { GRID_PROPERTY_TYPES } from \"@egjs/grid\";\nimport { diff } from \"@egjs/list-differ\";\nimport { GROUP_TYPE, IGNORE_PROPERITES_MAP, INFINITEGRID_METHODS, ITEM_INFO_PROPERTIES, ITEM_TYPE } from \"./consts\";\nimport { GroupManagerStatus, InfiniteGridGroupStatus } from \"./GroupManager\";\nimport InfiniteGrid from \"./InfiniteGrid\";\nimport { InfiniteGridItem, InfiniteGridItemStatus } from \"./InfiniteGridItem\";\nimport {\n  CategorizedGroup, InfiniteGridGroup, InfiniteGridInsertedItems,\n  InfiniteGridItemInfo,\n  RenderingOptions,\n} from \"./types\";\n\nexport function isWindow(el: Window | Element): el is Window {\n  return el === window;\n}\n\nexport function isNumber(val: any): val is number {\n  return typeof val === \"number\";\n}\n\nexport function isString(val: any): val is string {\n  return typeof val === \"string\";\n}\nexport function isObject(val: any): val is object {\n  return typeof val === \"object\";\n}\n\nexport function flat<T>(arr: T[][]): T[] {\n  return arr.reduce((prev, cur) => {\n    return [...prev, ...cur];\n  }, []);\n}\nexport function splitOptions(options: Record<string, any>) {\n  const {\n    gridOptions,\n    ...otherOptions\n  } = options;\n\n  return {\n    ...splitGridOptions(gridOptions),\n    ...otherOptions,\n  };\n}\nexport function splitGridOptions(options: Record<string, any>) {\n  const nextOptions: Record<string, any> = {};\n  const gridOptions: Record<string, any> = {};\n  const defaultOptions = Grid.defaultOptions;\n\n  for (const name in options) {\n    const value = options[name];\n\n    if (!(name in IGNORE_PROPERITES_MAP)) {\n      gridOptions[name] = value;\n    }\n\n    if (name in defaultOptions) {\n      nextOptions[name] = value;\n    }\n  }\n  return {\n    ...nextOptions,\n    gridOptions,\n  };\n}\n\nexport function categorize<Item extends InfiniteGridItemInfo = InfiniteGridItem>(items: Item[]) {\n  const groups: Array<CategorizedGroup<Item>> = [];\n  const groupKeys: Record<string | number, CategorizedGroup<Item>> = {};\n  const registeredGroupKeys: Record<string | number, boolean> = {};\n\n  items.filter((item) => item.groupKey != null).forEach(({ groupKey }) => {\n    registeredGroupKeys[groupKey!] = true;\n  });\n\n  let generatedGroupKey: number | string;\n  let isContinuousGroupKey = false;\n\n  items.forEach((item, i) => {\n    if (item.groupKey != null) {\n      isContinuousGroupKey = false;\n    } else if (!item.inserted && items[i - 1]) {\n      // In case of framework, inserted is false.\n      // If groupKey is not set, the group key of the previous item is followed.\n      item.groupKey = items[i - 1].groupKey!;\n      isContinuousGroupKey = false;\n    } else {\n      if (!isContinuousGroupKey) {\n        generatedGroupKey = makeKey(registeredGroupKeys);\n        isContinuousGroupKey = true;\n        registeredGroupKeys[generatedGroupKey] = true;\n      }\n      item.groupKey = generatedGroupKey;\n    }\n\n    const groupKey = item.groupKey;\n    let group = groupKeys[groupKey];\n\n    if (!group) {\n      group = {\n        groupKey,\n        items: [],\n      };\n      groupKeys[groupKey] = group;\n      groups.push(group);\n    }\n\n    group.items.push(item);\n  });\n  return groups;\n}\n\nexport function getNextCursors(\n  prevKeys: Array<string | number>,\n  nextKeys: Array<string | number>,\n  prevStartCursor: number,\n  prevEndCursor: number,\n) {\n  const result = diff(prevKeys, nextKeys, (key) => key);\n  let nextStartCursor = -1;\n  let nextEndCursor = -1;\n\n  // sync cursors\n  result.maintained.forEach(([prevIndex, nextIndex]) => {\n    if (prevStartCursor <= prevIndex && prevIndex <= prevEndCursor) {\n      if (nextStartCursor === -1) {\n        nextStartCursor = nextIndex;\n        nextEndCursor = nextIndex;\n      } else {\n        nextStartCursor = Math.min(nextStartCursor, nextIndex);\n        nextEndCursor = Math.max(nextEndCursor, nextIndex);\n      }\n    }\n  });\n  return {\n    startCursor: nextStartCursor,\n    endCursor: nextEndCursor,\n  };\n}\nexport function splitVirtualGroups<Group extends { type: GROUP_TYPE, groupKey: string | number }>(\n  groups: Group[],\n  direction: \"start\" | \"end\",\n  nextGroups: CategorizedGroup<InfiniteGridItemStatus>[],\n) {\n  let virtualGroups: Group[] = [];\n\n  if (direction === \"start\") {\n    const index = findIndex(groups, (group) => group.type === GROUP_TYPE.NORMAL);\n\n    if (index === -1) {\n      return [];\n    }\n    // Get the virtual group maintained in the group from the next group.\n    const endMaintainedIndex = findIndex(groups, (group) => {\n      return findIndex(nextGroups, (nextGroup) => nextGroup.groupKey === group.groupKey) >= 0;\n    });\n    const endIndex = endMaintainedIndex >= 0 ? Math.min(index, endMaintainedIndex) : index;\n\n    virtualGroups = groups.slice(0, endIndex);\n  } else {\n    const index = findLastIndex(groups, (group) => group.type === GROUP_TYPE.NORMAL);\n\n    if (index === -1) {\n      return [];\n    }\n    const startMaintainedIndex = findLastIndex(groups, (group) => {\n      return findIndex(nextGroups, (nextGroup) => nextGroup.groupKey === group.groupKey) >= 0;\n    });\n    const startIndex = startMaintainedIndex >= 0 ? Math.max(index, startMaintainedIndex) : index;\n\n    virtualGroups = groups.slice(startIndex + 1);\n  }\n\n  return virtualGroups;\n}\n\nexport function getFirstRenderingItems(\n  nextItems: InfiniteGridItemStatus[],\n  horizontal: boolean,\n) {\n  const groups = categorize(nextItems);\n\n  if (!groups[0]) {\n    return [];\n  }\n  return groups[0].items.map((item) => {\n    return new InfiniteGridItem(horizontal, {\n      ...item,\n    });\n  });\n}\nexport function getRenderingItemsByStatus(\n  groupManagerStatus: GroupManagerStatus,\n  nextItems: InfiniteGridItemStatus[],\n  usePlaceholder: boolean,\n  horizontal: boolean,\n) {\n  const prevGroups = groupManagerStatus.groups;\n  const groups = categorize(nextItems);\n\n  const startVirtualGroups = splitVirtualGroups(prevGroups, \"start\", groups);\n  const endVirtualGroups = splitVirtualGroups(prevGroups, \"end\", groups);\n  const nextGroups = [\n    ...startVirtualGroups,\n    ...groups,\n    ...endVirtualGroups,\n  ] as Array<InfiniteGridGroupStatus | CategorizedGroup<InfiniteGridItemStatus>>;\n  const {\n    startCursor,\n    endCursor,\n  } = getNextCursors(\n    prevGroups.map((group) => group.groupKey),\n    nextGroups.map((group) => group.groupKey),\n    groupManagerStatus.cursors[0],\n    groupManagerStatus.cursors[1],\n  );\n\n  let nextVisibleItems = flat(nextGroups.slice(startCursor, endCursor + 1).map((group) => {\n    return group.items.map((item) => {\n      return new InfiniteGridItem(horizontal, { ...item });\n    });\n  }));\n\n  if (!usePlaceholder) {\n    nextVisibleItems = nextVisibleItems.filter((item) => {\n      return item.type !== ITEM_TYPE.VIRTUAL;\n    });\n  }\n\n  return nextVisibleItems;\n}\n\nexport function mountRenderingItems(items: InfiniteGridItemInfo[], options: RenderingOptions) {\n  const {\n    grid,\n    usePlaceholder,\n    useLoading,\n    useFirstRender,\n    status,\n  } = options;\n  if (!grid) {\n    return;\n  }\n  if (usePlaceholder) {\n    grid.setPlaceholder({});\n  }\n  if (useLoading) {\n    grid.setLoading({});\n  }\n  if (status) {\n    grid.setStatus(status, true);\n  }\n\n  grid.syncItems(items);\n\n  if (useFirstRender && !status && grid.getGroups().length) {\n    grid.setCursors(0, 0, true);\n  }\n}\nexport function getRenderingItems(items: InfiniteGridItemInfo[], options: RenderingOptions) {\n  const {\n    status,\n    usePlaceholder,\n    useLoading,\n    horizontal,\n    useFirstRender,\n    grid,\n  } = options;\n  let visibleItems: InfiniteGridItem[] = [];\n\n  if (grid) {\n    grid.setPlaceholder(usePlaceholder ? {} : null);\n    grid.setLoading(useLoading ? {} : null);\n    grid.syncItems(items);\n\n    visibleItems = grid.getRenderingItems();\n  } else if (status) {\n    visibleItems = getRenderingItemsByStatus(status.groupManager, items, !!usePlaceholder, !!horizontal);\n  } else if (useFirstRender) {\n    visibleItems = getFirstRenderingItems(items, !!horizontal);\n  }\n\n  return visibleItems;\n}\n\n/* Class Decorator */\nexport function InfiniteGridGetterSetter(component: {\n  prototype: InfiniteGrid<any>,\n  propertyTypes: typeof GRID_PROPERTY_TYPES,\n}) {\n  const {\n    prototype,\n    propertyTypes,\n  } = component;\n  for (const name in propertyTypes) {\n    const attributes: Record<string, any> = {\n      enumerable: true,\n      configurable: true,\n      get(this: InfiniteGrid) {\n        const options = this.groupManager.options;\n        if (name in options) {\n          return options[name];\n        } else {\n          return options.gridOptions[name];\n        }\n      },\n      set(this: InfiniteGrid, value: any) {\n        const prevValue = this.groupManager[name];\n\n        if (prevValue === value) {\n          return;\n        }\n        this.groupManager.gridOptions = {\n          [name]: value,\n        };\n      },\n    };\n    Object.defineProperty(prototype, name, attributes);\n  }\n}\n\nexport function makeKey(\n  registeredKeys: Record<string, any>,\n  prefix = \"\",\n) {\n  let index = 0;\n  // eslint-disable-next-line no-constant-condition\n  while (true) {\n    const key = `infinitegrid_${prefix}${index++}`;\n\n    if (!(key in registeredKeys)) {\n      return key;\n    }\n  }\n}\n\nexport function convertHTMLtoElement(html: string) {\n  const dummy = document.createElement(\"div\");\n\n  dummy.innerHTML = html;\n  return toArray(dummy.children);\n}\n\nexport function convertInsertedItems(\n  items: InfiniteGridInsertedItems,\n  groupKey?: string | number,\n): InfiniteGridItemInfo[] {\n  let insertedItems: Array<string | HTMLElement | InfiniteGridItemInfo>;\n\n  if (isString(items)) {\n    insertedItems = convertHTMLtoElement(items);\n  } else {\n    insertedItems = items;\n  }\n  return insertedItems.map((item) => {\n    let element!: HTMLElement;\n    let html = \"\";\n    let key!: string | number;\n\n    if (isString(item)) {\n      html = item;\n    } else if (\"parentNode\" in item) {\n      element = item;\n      html = item.outerHTML;\n    } else {\n      // inserted is true when adding via a method.\n      return { groupKey, inserted: true, ...item };\n    }\n\n    // inserted is true when adding via a method.\n    return {\n      key,\n      groupKey,\n      html,\n      element,\n      inserted: true,\n    };\n  });\n}\nexport function toArray(nodes: HTMLCollection): HTMLElement[];\nexport function toArray<T>(nodes: { length: number, [key: number]: T }): T[];\nexport function toArray<T>(nodes: { length: number, [key: number]: T }): T[] {\n  const array: T[] = [];\n\n  if (nodes) {\n    const length = nodes.length;\n\n    for (let i = 0; i < length; i++) {\n      array.push(nodes[i]);\n    }\n  }\n  return array;\n}\n\n\nexport function find<T>(arr: T[], callback: (value: T, index: number) => boolean): T | null {\n  const length = arr.length;\n\n  for (let i = 0; i < length; ++i) {\n    const value = arr[i];\n\n    if (callback(value, i)) {\n      return value;\n    }\n  }\n\n  return null;\n}\n\nexport function findIndex<T>(arr: T[], callback: (value: T, index: number) => boolean) {\n  const length = arr.length;\n  for (let i = 0; i < length; ++i) {\n    if (callback(arr[i], i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nexport function findLastIndex<T>(arr: T[], callback: (value: T, index: number) => boolean) {\n  const length = arr.length;\n  for (let i = length - 1; i >= 0; --i) {\n    if (callback(arr[i], i)) {\n      return i;\n    }\n  }\n\n  return -1;\n}\n\nexport function getItemInfo(info: InfiniteGridItemInfo) {\n  const nextInfo: InfiniteGridItemInfo = {};\n\n  for (const name in info) {\n    if (name in ITEM_INFO_PROPERTIES) {\n      nextInfo[name] = info[name];\n    }\n  }\n\n  return nextInfo;\n}\n\nexport function setPlaceholder(item: InfiniteGridItem, info: InfiniteGridItemStatus) {\n  for (const name in info) {\n    const value = info[name];\n\n    if (isObject(value)) {\n      item[name] = {\n        ...item[name],\n        ...value,\n      };\n    } else {\n      item[name] = info[name];\n    }\n  }\n}\n\nexport function isFlatOutline(start: number[], end: number[]) {\n  return start.length === end.length && start.every((pos, i) => end[i] === pos);\n}\n\nexport function range(length: number): number[] {\n  const arr: number[] = [];\n  for (let i = 0; i < length; ++i) {\n    arr.push(i);\n  }\n  return arr;\n}\n\nexport function flatGroups(groups: InfiniteGridGroup[]) {\n  return flat(groups.map(({ grid }) => grid.getItems() as InfiniteGridItem[]));\n}\n\n\nexport function filterVirtuals<T extends InfiniteGridItem | InfiniteGridGroup>(\n  items: T[],\n  includePlaceholders?: boolean\n): T[] {\n  if (includePlaceholders) {\n    return [...items];\n  } else {\n    return items.filter((item) => item.type !== ITEM_TYPE.VIRTUAL);\n  }\n}\n\n/**\n * Decorator that makes the method of InfiniteGrid available in the framework.\n * @ko 프레임워크에서 InfiniteGrid의 메소드를 사용할 수 있게 하는 데코레이터.\n * @private\n * @example\n * ```js\n * import { withInfiniteGridMethods } from \"@egjs/infinitegrid\";\n *\n * class Grid extends React.Component<Partial<InfiniteGridProps & InfiniteGridOptions>> {\n *   &#64;withInfiniteGridMethods\n *   private grid: NativeGrid;\n * }\n * ```\n */\nexport const withInfiniteGridMethods = withClassMethods(INFINITEGRID_METHODS);\n\n","import Grid, {\n  GetterSetter,\n  GridFunction, GridItem, GridOptions,\n  GridOutlines, MOUNT_STATE, Properties, PROPERTY_TYPE,\n  RenderOptions, UPDATE_STATE,\n} from \"@egjs/grid\";\nimport { GROUP_TYPE, ITEM_TYPE, STATUS_TYPE } from \"./consts\";\nimport { InfiniteGridItem, InfiniteGridItemStatus } from \"./InfiniteGridItem\";\nimport { LoadingGrid, LOADING_GROUP_KEY } from \"./LoadingGrid\";\nimport { CategorizedGroup, InfiniteGridGroup, InfiniteGridItemInfo } from \"./types\";\nimport {\n  categorize, filterVirtuals, findIndex, findLastIndex,\n  flat,\n  flatGroups, getItemInfo, isNumber, makeKey,\n  range,\n  setPlaceholder,\n  splitGridOptions, splitOptions, splitVirtualGroups,\n} from \"./utils\";\n\nexport interface InfiniteGridGroupStatus {\n  type: GROUP_TYPE;\n  groupKey: string | number;\n  items: InfiniteGridItemStatus[];\n  outlines: GridOutlines;\n}\n\nexport interface GroupManagerOptions extends GridOptions {\n  appliedItemChecker?: (item: InfiniteGridItem, grid: Grid) => boolean;\n  gridConstructor: GridFunction | null;\n  gridOptions: Record<string, any>;\n}\n\nexport interface GroupManagerStatus {\n  cursors: [number, number];\n  orgCursors: [number, number];\n  itemCursors: [number, number];\n  startGroupKey: number | string;\n  endGroupKey: number | string;\n  groups: InfiniteGridGroupStatus[];\n  outlines: GridOutlines;\n}\n\n@GetterSetter\nexport class GroupManager extends Grid<GroupManagerOptions> {\n  public static defaultOptions: Required<GroupManagerOptions> = {\n    ...Grid.defaultOptions,\n    appliedItemChecker: () => false,\n    gridConstructor: null,\n    gridOptions: {},\n  };\n  public static propertyTypes = {\n    ...Grid.propertyTypes,\n    gridConstructor: PROPERTY_TYPE.PROPERTY,\n    gridOptions: PROPERTY_TYPE.PROPERTY,\n  } as const;\n  protected items: InfiniteGridItem[];\n  protected groupItems: InfiniteGridItem[] = [];\n  protected groups: InfiniteGridGroup[] = [];\n  protected itemKeys: Record<string | number, InfiniteGridItem> = {};\n  protected groupKeys: Record<string | number, InfiniteGridGroup> = {};\n  protected startCursor = 0;\n  protected endCursor = 0;\n  private _placeholder: Partial<InfiniteGridItemStatus> | null = null;\n  private _loadingGrid!: LoadingGrid;\n  private _mainGrid!: Grid;\n\n  constructor(container: HTMLElement, options: GroupManagerOptions) {\n    super(container, splitOptions(options));\n\n    this._loadingGrid = new LoadingGrid(container, {\n      externalContainerManager: this.containerManager,\n      useFit: false,\n      autoResize: false,\n      renderOnPropertyChange: false,\n      gap: this.gap,\n    });\n    this._mainGrid = this._makeGrid();\n  }\n  public set gridOptions(options: Record<string, any>) {\n    const {\n      gridOptions,\n      ...otherOptions\n    } = splitGridOptions(options);\n\n    const shouldRender = this._checkShouldRender(options);\n    this.options.gridOptions = {\n      ...this.options.gridOptions,\n      ...gridOptions,\n    };\n    [this._mainGrid, ...this.groups.map(({ grid }) => grid)].forEach((grid) => {\n      for (const name in options) {\n        (grid as any)[name] = options[name];\n      }\n    });\n    for (const name in otherOptions) {\n      this[name] = otherOptions[name];\n    }\n\n    this._loadingGrid.gap = this.gap;\n    if (shouldRender) {\n      this.scheduleRender();\n    }\n  }\n\n  public getItemByKey(key: string | number): InfiniteGridItem | null {\n    return this.itemKeys[key] || null;\n  }\n\n  public getGroupItems(includePlaceholders?: boolean) {\n    return filterVirtuals(this.groupItems, includePlaceholders);\n  }\n  public getVisibleItems(includePlaceholders?: boolean) {\n    return filterVirtuals(this.items, includePlaceholders);\n  }\n\n  public getRenderingItems() {\n    if (this.hasPlaceholder()) {\n      return this.items;\n    } else {\n      return this.items.filter((item) => item.type !== ITEM_TYPE.VIRTUAL);\n    }\n  }\n\n  public getGroups(includePlaceholders?: boolean): InfiniteGridGroup[] {\n    return filterVirtuals(this.groups, includePlaceholders);\n  }\n\n  public hasVisibleVirtualGroups() {\n    return this.getVisibleGroups(true).some((group) => group.type === GROUP_TYPE.VIRTUAL);\n  }\n  public hasPlaceholder() {\n    return !!this._placeholder;\n  }\n  public hasLoadingItem() {\n    return !!this._getLoadingItem();\n  }\n\n  public updateItems(items = this.groupItems, options?: RenderOptions) {\n    return super.updateItems(items, options);\n  }\n  public setPlaceholder(placeholder: Partial<InfiniteGridItemStatus> | null) {\n    this._placeholder = placeholder;\n    this._updatePlaceholder();\n  }\n\n  public getLoadingType() {\n    return this._loadingGrid.type;\n  }\n\n  public startLoading(type: \"start\" | \"end\") {\n    this._loadingGrid.type = type;\n    this.items = this._getRenderingItems();\n\n    return true;\n  }\n\n  public waitEndLoading() {\n    if (this._loadingGrid.type) {\n      this._loadingGrid.isWaitEnd = true;\n      return true;\n    }\n    return false;\n  }\n\n  public endLoading() {\n    if (this._loadingGrid.isWaitEnd) {\n      const prevType = this._loadingGrid.type;\n\n      this._loadingGrid.type = \"\";\n      this._loadingGrid.endLoading();\n      this.items = this._getRenderingItems();\n      return !!prevType;\n    }\n    return false;\n  }\n\n  public setLoading(loading: Partial<InfiniteGridItemStatus> | null) {\n    this._loadingGrid.setLoadingItem(loading);\n    this.items = this._getRenderingItems();\n  }\n\n  public getVisibleGroups(includePlaceholders?: boolean): InfiniteGridGroup[] {\n    const groups = this.groups.slice(this.startCursor, this.endCursor + 1);\n\n    return filterVirtuals(groups, includePlaceholders);\n  }\n\n  public getComputedOutlineLength(items = this.items) {\n    return this._mainGrid.getComputedOutlineLength(items);\n  }\n  public getComputedOutlineSize(items = this.items) {\n    return this._mainGrid.getComputedOutlineSize(items);\n  }\n\n  public applyGrid(items: InfiniteGridItem[], direction: \"end\" | \"start\", outline: number[]): GridOutlines {\n    const renderingGroups = this.groups.slice();\n\n    if (!renderingGroups.length) {\n      return {\n        start: [],\n        end: [],\n      };\n    }\n\n\n    const loadingGrid = this._loadingGrid;\n\n    if (loadingGrid.getLoadingItem()) {\n      if (loadingGrid.type === \"start\") {\n        renderingGroups.unshift(this._getLoadingGroup());\n      } else if (loadingGrid.type === \"end\") {\n        renderingGroups.push(this._getLoadingGroup());\n      }\n    }\n\n    const groups = renderingGroups.slice();\n\n    let nextOutline = outline;\n\n    if (direction === \"start\") {\n      groups.reverse();\n    }\n\n    const appliedItemChecker = this.options.appliedItemChecker;\n    const groupItems = this.groupItems;\n    const outlineLength = this.getComputedOutlineLength(groupItems);\n    const outlineSize = this.getComputedOutlineSize(groupItems);\n    const itemRenderer = this.itemRenderer;\n    let passedItems: InfiniteGridItem[] = [];\n\n    groups.forEach((group) => {\n      const grid = group.grid;\n      const gridItems = grid.getItems() as InfiniteGridItem[];\n      const isVirtual = group.type === GROUP_TYPE.VIRTUAL && !gridItems[0];\n\n      passedItems = direction === \"end\" ? [...passedItems, ...gridItems] : [...gridItems, ...passedItems];\n      grid.outlineLength = outlineLength;\n      grid.outlineSize = outlineSize;\n\n      const appliedItems = passedItems.filter((item) => {\n        if (item.mountState === MOUNT_STATE.UNCHECKED || !item.rect.width) {\n          itemRenderer.updateItem(item, true);\n        }\n        return (item.orgRect.width && item.rect.width) || appliedItemChecker(item, grid);\n      });\n      let gridOutlines: GridOutlines;\n\n      if (isVirtual) {\n        gridOutlines = this._applyVirtualGrid(grid, direction, nextOutline);\n      } else if (appliedItems.length) {\n        gridOutlines = grid.applyGrid(appliedItems, direction, nextOutline);\n      } else {\n        gridOutlines = {\n          start: [...nextOutline],\n          end: [...nextOutline],\n        };\n      }\n\n      grid.setOutlines(gridOutlines);\n      nextOutline = gridOutlines.passed || gridOutlines[direction];\n      passedItems = gridOutlines.passedItems?.map((index) => passedItems[index]) ?? [];\n    });\n\n    return {\n      start: renderingGroups[0].grid.getOutlines().start,\n      end: renderingGroups[renderingGroups.length - 1].grid.getOutlines().end,\n    };\n  }\n\n  public syncItems(nextItemInfos: InfiniteGridItemInfo[]) {\n    const prevItemKeys = this.itemKeys;\n\n    this.itemKeys = {};\n    const nextItems = this._syncItemInfos(nextItemInfos.map((info) => getItemInfo(info)), prevItemKeys);\n    const prevGroupKeys = this.groupKeys;\n    let nextManagerGroups = categorize(nextItems);\n\n    const startVirtualGroups = this._splitVirtualGroups(\"start\", nextManagerGroups);\n    const endVirtualGroups = this._splitVirtualGroups(\"end\", nextManagerGroups);\n    nextManagerGroups = [...startVirtualGroups, ...this._mergeVirtualGroups(nextManagerGroups), ...endVirtualGroups];\n\n    const nextGroups: InfiniteGridGroup[] = nextManagerGroups.map(({ groupKey, items }) => {\n      const isVirtual = !items[0] || items[0].type === ITEM_TYPE.VIRTUAL;\n      const grid = prevGroupKeys[groupKey]?.grid ?? this._makeGrid();\n      const gridItems = isVirtual ? items : items.filter(({ type }) => type === ITEM_TYPE.NORMAL);\n\n      grid.setItems(gridItems);\n\n      return {\n        type: isVirtual ? GROUP_TYPE.VIRTUAL : GROUP_TYPE.NORMAL,\n        groupKey,\n        grid,\n        items: gridItems,\n        renderItems: items,\n      };\n    });\n\n    this._registerGroups(nextGroups);\n  }\n\n  public renderItems(options: RenderOptions = {}) {\n    if (options.useResize) {\n      this.groupItems.forEach((item) => {\n        item.updateState = UPDATE_STATE.NEED_UPDATE;\n      });\n      const loadingItem = this._getLoadingItem();\n\n      if (loadingItem) {\n        loadingItem.updateState = UPDATE_STATE.NEED_UPDATE;\n      }\n    }\n    return super.renderItems(options);\n  }\n\n  public setCursors(startCursor: number, endCursor: number) {\n    this.startCursor = startCursor;\n    this.endCursor = endCursor;\n    this.items = this._getRenderingItems();\n  }\n\n  public getStartCursor() {\n    return this.startCursor;\n  }\n\n  public getEndCursor() {\n    return this.endCursor;\n  }\n\n  public getGroupStatus(type?: STATUS_TYPE, includePlaceholders?: boolean): GroupManagerStatus {\n    const orgStartCursor = this.startCursor;\n    const orgEndCursor = this.endCursor;\n    const orgGroups = this.groups;\n    const startGroup = orgGroups[orgStartCursor];\n    const endGroup = orgGroups[orgEndCursor];\n\n    let startCursor = orgStartCursor;\n    let endCursor = orgEndCursor;\n\n    const isMinimizeItems = type === STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS;\n    const isMinimizeGroups = type === STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS;\n    let groups: InfiniteGridGroup[];\n\n    if (type === STATUS_TYPE.REMOVE_INVISIBLE_GROUPS) {\n      groups = this.getVisibleGroups(includePlaceholders);\n      endCursor = groups.length - 1;\n      startCursor = 0;\n    } else {\n      groups = this.getGroups(includePlaceholders);\n\n      if (!includePlaceholders) {\n        startCursor = -1;\n        endCursor = -1;\n\n        for (let orgIndex = orgStartCursor; orgIndex <= orgEndCursor; ++orgIndex) {\n          const orgGroup = orgGroups[orgIndex];\n\n          if (orgGroup && orgGroup.type !== GROUP_TYPE.VIRTUAL) {\n            startCursor = groups.indexOf(orgGroup);\n            break;\n          }\n        }\n        for (let orgIndex = orgEndCursor; orgIndex >= orgStartCursor; --orgIndex) {\n          const orgGroup = orgGroups[orgIndex];\n\n          if (orgGroup && orgGroup.type !== GROUP_TYPE.VIRTUAL) {\n            endCursor = groups.lastIndexOf(orgGroup);\n            break;\n          }\n        }\n      }\n    }\n\n    const groupStatus: InfiniteGridGroupStatus[] = groups.map(({ grid, groupKey }, i) => {\n      const isOutsideCursor = i < startCursor || endCursor < i;\n      const isVirtualItems = isMinimizeItems && isOutsideCursor;\n      const isVirtualGroup = isMinimizeGroups && isOutsideCursor;\n      const gridItems = grid.getItems() as InfiniteGridItem[];\n      const items = isVirtualGroup\n        ? []\n        : gridItems.map((item) => isVirtualItems ? item.getVirtualStatus() : item.getMinimizedStatus());\n\n      return {\n        type: isVirtualGroup || isVirtualItems ? GROUP_TYPE.VIRTUAL : GROUP_TYPE.NORMAL,\n        groupKey: groupKey,\n        outlines: grid.getOutlines(),\n        items,\n      };\n    });\n\n\n    const totalItems = this.getGroupItems();\n\n    const itemStartCursor = totalItems.indexOf(startGroup?.items[0]);\n    const itemEndCursor = totalItems.indexOf(endGroup?.items.slice().reverse()[0]);\n\n    return {\n      cursors: [startCursor, endCursor],\n      orgCursors: [orgStartCursor, orgEndCursor],\n      itemCursors: [itemStartCursor, itemEndCursor],\n      startGroupKey: startGroup?.groupKey,\n      endGroupKey: endGroup?.groupKey,\n      groups: groupStatus,\n      outlines: this.outlines,\n    };\n  }\n  protected fitOutlines(useFit = this.useFit) {\n    const groups = this.groups;\n\n    if (!groups[0]) {\n      return;\n    }\n    const outlines = this.outlines;\n    const startOutline = outlines.start;\n    const outlineOffset = startOutline.length ? Math.min(...startOutline) : 0;\n\n    // If the outline is less than 0, a fit occurs forcibly.\n    if (!useFit && outlineOffset > 0) {\n      return;\n    }\n\n    groups.forEach(({ grid }) => {\n      const { start, end } = grid.getOutlines();\n\n      grid.setOutlines({\n        start: start.map((point) => point - outlineOffset),\n        end: end.map((point) => point - outlineOffset),\n      });\n    });\n\n    this.groupItems.forEach((item) => {\n      const contentPos = item.cssContentPos;\n\n      if (!isNumber(contentPos)) {\n        return;\n      }\n      item.cssContentPos = contentPos - outlineOffset;\n    });\n  }\n  public setGroupStatus(status: GroupManagerStatus) {\n    this.itemKeys = {};\n    this.groupItems = [];\n    this.items = [];\n    const prevGroupKeys = this.groupKeys;\n\n    const nextGroups: InfiniteGridGroup[] = status.groups.map(({\n      type,\n      groupKey,\n      items,\n      outlines,\n    }) => {\n      const nextItems = this._syncItemInfos(items);\n      const grid = prevGroupKeys[groupKey]?.grid ?? this._makeGrid();\n\n      grid.setOutlines(outlines);\n      grid.setItems(nextItems);\n\n      return {\n        type,\n        groupKey,\n        grid,\n        items: nextItems,\n        renderItems: nextItems,\n      };\n    });\n\n    this.setOutlines(status.outlines);\n    this._registerGroups(nextGroups);\n    this._updatePlaceholder();\n    this.setCursors(status.cursors[0], status.cursors[1]);\n  }\n  public appendPlaceholders(items: number | InfiniteGridItemStatus[], groupKey?: string | number) {\n    return this.insertPlaceholders(\"end\", items, groupKey);\n  }\n  public prependPlaceholders(items: number | InfiniteGridItemStatus[], groupKey?: string | number) {\n    return this.insertPlaceholders(\"start\", items, groupKey);\n  }\n  public removePlaceholders(type: \"start\" | \"end\" | { groupKey: string | number }) {\n    const groups = this.groups;\n    const length = groups.length;\n\n    if (type === \"start\") {\n      const index = findIndex(groups, (group) => group.type === GROUP_TYPE.NORMAL);\n\n      groups.splice(0, index);\n\n    } else if (type === \"end\") {\n      const index = findLastIndex(groups, (group) => group.type === GROUP_TYPE.NORMAL);\n\n      groups.splice(index + 1, length - index - 1);\n    } else {\n      const groupKey = type.groupKey;\n\n      const index = findIndex(groups, (group) => group.groupKey === groupKey);\n\n      if (index > -1) {\n        groups.splice(index, 1);\n      }\n    }\n\n    this.syncItems(flatGroups(this.getGroups()));\n  }\n  public insertPlaceholders(\n    direction: \"start\" | \"end\",\n    items: number | InfiniteGridItemStatus[],\n    groupKey: string | number = makeKey(this.groupKeys, \"virtual_\"),\n  ) {\n\n    let infos: InfiniteGridItemInfo[] = [];\n\n    if (isNumber(items)) {\n      infos = range(items).map(() => ({ type: ITEM_TYPE.VIRTUAL, groupKey }));\n    } else if (Array.isArray(items)) {\n      infos = items.map((status) => ({\n        groupKey,\n        ...status,\n        type: ITEM_TYPE.VIRTUAL,\n      }));\n    }\n    const grid = this._makeGrid();\n    const nextItems = this._syncItemInfos(infos, this.itemKeys);\n\n    this._updatePlaceholder(nextItems);\n    grid.setItems(nextItems);\n\n    const group = {\n      type: GROUP_TYPE.VIRTUAL,\n      groupKey,\n      grid,\n      items: nextItems,\n      renderItems: nextItems,\n    };\n\n    this.groupKeys[groupKey] = group;\n\n    if (direction === \"end\") {\n      this.groups.push(group);\n      this.groupItems.push(...nextItems);\n    } else {\n      this.groups.splice(0, 0, group);\n      this.groupItems.splice(0, 0, ...nextItems);\n      if (this.startCursor > -1) {\n        ++this.startCursor;\n        ++this.endCursor;\n      }\n    }\n\n\n    return {\n      group,\n      items: nextItems,\n    };\n  }\n\n  public shouldRerenderItems() {\n    let isRerender = false;\n\n    this.getVisibleGroups().forEach((group) => {\n      const items = group.items;\n\n      if (\n        items.length === group.renderItems.length\n        || items.every((item) => item.mountState === MOUNT_STATE.UNCHECKED)\n      ) {\n        return;\n      }\n      isRerender = true;\n      group.renderItems = [...items];\n    });\n    if (isRerender) {\n      this.items = this._getRenderingItems();\n    }\n    return isRerender;\n  }\n\n  // protected checkReady(options: RenderOptions = {}) {\n  //   const items = this.items;\n  //   const updated = items.filter((item) => item.element?.parentNode && item.updateState !== UPDATE_STATE.UPDATED);\n  //   const mounted = items.filter((item) => item.element?.parentNode && item.mountState !== MOUNT_STATE.MOUNTED);\n\n\n  //   if (updated.length && updated.every((item) => item.type != ITEM_TYPE.NORMAL)) {\n  //     this._updateItems(updated);\n  //     this.readyItems(mounted, updated, options);\n  //   } else {\n  //     super.checkReady(options);\n  //   }\n  // }\n  protected _updateItems(items: GridItem[]): void {\n    this.itemRenderer.updateEqualSizeItems(items, this.groupItems);\n  }\n\n  private _getGroupItems() {\n    return flatGroups(this.getGroups(true));\n  }\n\n  private _getRenderingItems() {\n    const items = flat(this.getVisibleGroups(true).map((item) => item.renderItems));\n\n\n    const loadingGrid = this._loadingGrid;\n    const loadingItem = loadingGrid.getLoadingItem();\n\n    if (loadingItem) {\n      if (loadingGrid.type === \"end\") {\n        items.push(loadingItem);\n      } else if (loadingGrid.type === \"start\") {\n        items.unshift(loadingItem);\n      }\n    }\n\n    return items;\n  }\n\n  private _checkShouldRender(options: Record<string, any>) {\n    const GridConstructor = this.options.gridConstructor!;\n    const prevOptions = this.gridOptions;\n    const propertyTypes = GridConstructor.propertyTypes;\n\n    for (const name in prevOptions) {\n      if (!(name in options) && propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY) {\n        return true;\n      }\n    }\n    for (const name in options) {\n      if (prevOptions[name] !== options[name] && propertyTypes[name] === PROPERTY_TYPE.RENDER_PROPERTY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  private _applyVirtualGrid(grid: Grid, direction: \"start\" | \"end\", outline: number[]) {\n    const startOutline = outline.length ? [...outline] : [0];\n    const prevOutlines = grid.getOutlines();\n    const prevOutline = prevOutlines[direction === \"end\" ? \"start\" : \"end\"];\n\n    if (\n      prevOutline.length !== startOutline.length\n      || prevOutline.some((value, i) => value !== startOutline[i])\n    ) {\n      return {\n        start: [...startOutline],\n        end: [...startOutline],\n      };\n    }\n    return prevOutlines;\n  }\n  private _syncItemInfos(\n    nextItemInfos: InfiniteGridItemStatus[],\n    prevItemKeys: Record<string | number, InfiniteGridItem> = {},\n  ) {\n    const horizontal = this.options.horizontal;\n    const nextItemKeys = this.itemKeys;\n\n    nextItemInfos.filter((info) => info.key != null).forEach((info) => {\n      const key = info.key!;\n      const prevItem = prevItemKeys[key];\n\n      if (!prevItem) {\n        nextItemKeys[key] = new InfiniteGridItem(horizontal, {\n          ...info,\n        });\n      } else if (prevItem.type === ITEM_TYPE.VIRTUAL && info.type !== ITEM_TYPE.VIRTUAL) {\n        nextItemKeys[key] = new InfiniteGridItem(horizontal, {\n          orgRect: prevItem.orgRect,\n          rect: prevItem.rect,\n          ...info,\n        });\n      } else {\n        if (info.data) {\n          prevItem.data = info.data;\n        }\n        if (info.groupKey != null) {\n          prevItem.groupKey = info.groupKey!;\n        }\n        if (info.element) {\n          prevItem.element = info.element;\n        }\n        nextItemKeys[key] = prevItem;\n      }\n    });\n    const nextItems = nextItemInfos.map((info) => {\n      let key = info.key!;\n\n      if (info.key == null) {\n        key = makeKey(nextItemKeys, info.type === ITEM_TYPE.VIRTUAL ? \"virtual_\" : \"\");\n      }\n      let item = nextItemKeys[key];\n\n      if (!item) {\n        const prevItem = prevItemKeys[key];\n\n        if (prevItem) {\n          item = prevItem;\n\n          if (info.data) {\n            item.data = info.data;\n          }\n          if (info.element) {\n            item.element = info.element;\n          }\n        } else {\n          item = new InfiniteGridItem(horizontal, {\n            ...info,\n            key,\n          });\n        }\n        nextItemKeys[key] = item;\n      }\n      return item;\n    });\n    return nextItems;\n  }\n  private _registerGroups(groups: InfiniteGridGroup[]) {\n    const nextGroupKeys: Record<string | number, InfiniteGridGroup> = {};\n\n    groups.forEach((group) => {\n      nextGroupKeys[group.groupKey] = group;\n    });\n\n    this.groups = groups;\n    this.groupKeys = nextGroupKeys;\n    this.groupItems = this._getGroupItems();\n  }\n  private _splitVirtualGroups(direction: \"start\" | \"end\", nextGroups: CategorizedGroup[]) {\n    const groups = splitVirtualGroups(this.groups, direction, nextGroups);\n    const itemKeys = this.itemKeys;\n\n    groups.forEach(({ renderItems }) => {\n      renderItems.forEach((item) => {\n        itemKeys[item.key] = item;\n      });\n    });\n\n    return groups;\n  }\n  private _mergeVirtualGroups(groups: Array<CategorizedGroup<InfiniteGridItem>>) {\n    const itemKeys = this.itemKeys;\n    const groupKeys = this.groupKeys;\n\n    groups.forEach((group) => {\n      const prevGroup = groupKeys[group.groupKey];\n\n      if (!prevGroup) {\n        return;\n      }\n      const items = group.items;\n\n      if (items.every((item) => item.mountState === MOUNT_STATE.UNCHECKED)) {\n        prevGroup.renderItems.forEach((item) => {\n          if (item.type === ITEM_TYPE.VIRTUAL && !itemKeys[item.key]) {\n            items.push(item);\n            itemKeys[item.key] = item;\n          }\n        });\n      }\n    });\n    return groups;\n  }\n\n  private _updatePlaceholder(items = this.groupItems) {\n    const placeholder = this._placeholder;\n\n    if (!placeholder) {\n      return;\n    }\n\n    items.filter((item) => item.type === ITEM_TYPE.VIRTUAL).forEach((item) => {\n      setPlaceholder(item, placeholder);\n    });\n  }\n  private _makeGrid() {\n    const GridConstructor = this.options.gridConstructor!;\n    const gridOptions = this.gridOptions;\n    const container = this.containerElement;\n\n    return new GridConstructor(container, {\n      ...gridOptions,\n      useFit: false,\n      autoResize: false,\n      useResizeObserver: false,\n      observeChildren: false,\n      renderOnPropertyChange: false,\n      externalContainerManager: this.containerManager,\n      externalItemRenderer: this.itemRenderer,\n    });\n  }\n  private _getLoadingGroup(): InfiniteGridGroup {\n    const loadingGrid = this._loadingGrid;\n    const items = loadingGrid.getItems() as InfiniteGridItem[];\n\n    return {\n      groupKey: LOADING_GROUP_KEY,\n      type: GROUP_TYPE.NORMAL,\n      grid: loadingGrid,\n      items,\n      renderItems: items,\n    };\n  }\n  private _getLoadingItem() {\n    return this._loadingGrid.getLoadingItem();\n  }\n}\n\nexport interface GroupManager extends Properties<typeof GroupManager> {\n  getItems(): InfiniteGridItem[];\n}\n","import Component from \"@egjs/component\";\nimport { diff } from \"@egjs/list-differ\";\nimport { DIRECTION } from \"./consts\";\nimport { findIndex, findLastIndex, getNextCursors, isFlatOutline } from \"./utils\";\n\nexport interface OnInfiniteRequestAppend {\n  key?: string | number | undefined;\n  nextKey?: string | number | undefined;\n  nextKeys?: Array<string | number>;\n  isVirtual: boolean;\n}\n\nexport interface OnInfiniteRequestPrepend {\n  key?: string | number;\n  nextKey?: string | number;\n  nextKeys?: Array<string | number>;\n  isVirtual: boolean;\n}\n\nexport interface OnInfiniteChange {\n  prevStartCursor: number;\n  prevEndCursor: number;\n  nextStartCursor: number;\n  nextEndCursor: number;\n}\n\nexport interface InfiniteEvents {\n  requestAppend: OnInfiniteRequestAppend;\n  requestPrepend: OnInfiniteRequestPrepend;\n  change: OnInfiniteChange;\n}\n\nexport interface InfiniteOptions {\n  useRecycle?: boolean;\n  threshold?: number;\n  defaultDirection?: \"start\" | \"end\";\n}\n\nexport interface InfiniteItemPart {\n  key: string | number;\n  pos: number;\n  size: number;\n}\nexport interface InfiniteItem {\n  key: string | number;\n  startOutline: number[];\n  endOutline: number[];\n  parts?: InfiniteItemPart[];\n  isVirtual?: boolean;\n}\n\nexport class Infinite extends Component<InfiniteEvents> {\n  public options: Required<InfiniteOptions>;\n  protected startCursor = -1;\n  protected endCursor = -1;\n  protected size = 0;\n  protected items: InfiniteItem[] = [];\n  protected itemKeys: Record<string | number, InfiniteItem> = {};\n  constructor(options: InfiniteOptions) {\n    super();\n    this.options = {\n      threshold: 0,\n      useRecycle: true,\n      defaultDirection: \"end\",\n      ...options,\n    };\n  }\n  public scroll(scrollPos: number) {\n    const prevStartCursor = this.startCursor;\n    const prevEndCursor = this.endCursor;\n    const items = this.items;\n    const length = items.length;\n    const size = this.size;\n    const {\n      defaultDirection,\n      threshold,\n      useRecycle,\n    } = this.options;\n    const isDirectionEnd = defaultDirection === \"end\";\n\n    if (!length) {\n      this.trigger(isDirectionEnd ? \"requestAppend\" : \"requestPrepend\", {\n        key: undefined,\n        isVirtual: false,\n      });\n      return;\n    } else if (prevStartCursor === -1 || prevEndCursor === -1) {\n      const nextCursor = isDirectionEnd ? 0 : length - 1;\n      this.trigger(\"change\", {\n        prevStartCursor,\n        prevEndCursor,\n        nextStartCursor: nextCursor,\n        nextEndCursor: nextCursor,\n      });\n      return;\n    }\n\n    const endScrollPos = scrollPos + size;\n    const startEdgePos = Math.max(...items[prevStartCursor].startOutline);\n    const endEdgePos = Math.min(...items[prevEndCursor].endOutline);\n    const visibles = items.map((item) => {\n      const {\n        startOutline,\n        endOutline,\n      } = item;\n\n      if (!startOutline.length || !endOutline.length || isFlatOutline(startOutline, endOutline)) {\n        return false;\n      }\n      const startPos = Math.min(...startOutline);\n      const endPos = Math.max(...endOutline);\n\n      if (startPos - threshold <= endScrollPos && scrollPos <= endPos + threshold) {\n        return true;\n      }\n      return false;\n    });\n    const hasStartItems = 0 < prevStartCursor;\n    const hasEndItems = prevEndCursor < length - 1;\n    const isStart = scrollPos <= startEdgePos + threshold;\n    const isEnd = endScrollPos >= endEdgePos - threshold;\n    let nextStartCursor = visibles.indexOf(true);\n    let nextEndCursor = visibles.lastIndexOf(true);\n\n    if (nextStartCursor === -1) {\n      nextStartCursor = prevStartCursor;\n      nextEndCursor = prevEndCursor;\n    }\n\n    if (!useRecycle) {\n      nextStartCursor = Math.min(nextStartCursor, prevStartCursor);\n      nextEndCursor = Math.max(nextEndCursor, prevEndCursor);\n    }\n    if (nextStartCursor === prevStartCursor && hasStartItems && isStart) {\n      nextStartCursor -= 1;\n    }\n    if (nextEndCursor === prevEndCursor && hasEndItems && isEnd) {\n      nextEndCursor += 1;\n    }\n    let nextVisibleItems = items.slice(nextStartCursor, nextEndCursor + 1);\n\n    // It must contain no virtual items.\n    if (nextVisibleItems.every((item) => item.isVirtual === true)) {\n      // The real item can be in either the start or end direction.\n      let hasRealItem = false;\n\n      for (let i = nextStartCursor - 1; i >= 0; --i) {\n        if (!items[i].isVirtual) {\n          nextStartCursor = i;\n          hasRealItem = true;\n          break;\n        }\n      }\n      if (!hasRealItem) {\n        for (let i = nextEndCursor + 1; i < length; ++i) {\n          if (!items[i].isVirtual) {\n            nextEndCursor = i;\n            hasRealItem = true;\n            break;\n          }\n        }\n      }\n      if (hasRealItem) {\n        nextVisibleItems = items.slice(nextStartCursor, nextEndCursor + 1);\n      }\n    }\n\n    const hasVirtualItems = nextVisibleItems.some((item) => item.isVirtual === true);\n\n    if (prevStartCursor !== nextStartCursor || prevEndCursor !== nextEndCursor) {\n      this.trigger(\"change\", {\n        prevStartCursor,\n        prevEndCursor,\n        nextStartCursor,\n        nextEndCursor,\n      });\n\n      if (!hasVirtualItems) {\n        return;\n      }\n    }\n\n    // If a virtual item is included, a requestPrepend (or requestAppend) event is triggered.\n    if (hasVirtualItems) {\n      const isStartVirtual = nextVisibleItems[0]?.isVirtual;\n      const isEndVirtual = nextVisibleItems[nextVisibleItems.length - 1]?.isVirtual;\n\n      if ((!isDirectionEnd || !isEnd) && isStartVirtual) {\n        const realItemIndex = findIndex(nextVisibleItems, (item) => !item.isVirtual);\n        const endVirtualItemIndex = (realItemIndex === -1 ? nextVisibleItems.length : realItemIndex) - 1;\n\n        if (nextVisibleItems[endVirtualItemIndex]) {\n          this.trigger(\"requestPrepend\", {\n            key: realItemIndex > -1 ? nextVisibleItems[realItemIndex].key : undefined,\n            nextKey: nextVisibleItems[endVirtualItemIndex].key,\n            nextKeys: nextVisibleItems.slice(0, endVirtualItemIndex + 1).map((item) => item.key),\n            isVirtual: true,\n          });\n        }\n      } else if ((isDirectionEnd || !isStart) && isEndVirtual) {\n        const realItemIndex = findLastIndex(nextVisibleItems, (item) => !item.isVirtual);\n        const startVirtualItemIndex = realItemIndex + 1;\n\n        if (nextVisibleItems[startVirtualItemIndex]) {\n          this.trigger(\"requestAppend\", {\n            key: realItemIndex > -1 ? nextVisibleItems[realItemIndex].key : undefined,\n            nextKey: nextVisibleItems[startVirtualItemIndex].key,\n            nextKeys: nextVisibleItems.slice(startVirtualItemIndex).map((item) => item.key),\n            isVirtual: true,\n          });\n        }\n      }\n    } else if (!this._requestVirtualItems()) {\n      if ((!isDirectionEnd || !isEnd) && isStart) {\n        this.trigger(\"requestPrepend\", {\n          key: items[prevStartCursor].key,\n          isVirtual: false,\n        });\n      } else if ((isDirectionEnd || !isStart) && isEnd) {\n        this.trigger(\"requestAppend\", {\n          key: items[prevEndCursor].key,\n          isVirtual: false,\n        });\n      }\n    }\n  }\n\n  /**\n   * Call the requestAppend or requestPrepend event to fill the virtual items.\n   * @ko virtual item을 채우기 위해 requestAppend 또는 requestPrepend 이벤트를 호출합니다.\n   * @return - Whether the event is called. <ko>이벤트를 호출했는지 여부.</ko>\n   */\n  public _requestVirtualItems() {\n    const isDirectionEnd = this.options.defaultDirection === \"end\";\n    const items = this.items;\n    const totalVisibleItems = this.getVisibleItems();\n    const visibleItems = totalVisibleItems.filter((item) => !item.isVirtual);\n    const totalVisibleLength = totalVisibleItems.length;\n    const visibleLength = visibleItems.length;\n    const startCursor = this.getStartCursor();\n    const endCursor = this.getEndCursor();\n\n    if (visibleLength === totalVisibleLength) {\n      return false;\n    } else if (visibleLength) {\n      const startKey = visibleItems[0].key;\n      const endKey = visibleItems[visibleLength - 1].key;\n      const startIndex = findIndex(items, (item) => item.key === startKey) - 1;\n      const endIndex = findIndex(items, (item) => item.key === endKey) + 1;\n\n      const isEnd = endIndex <= endCursor;\n      const isStart = startIndex >= startCursor;\n\n      // Fill the placeholder with the original item.\n      if ((isDirectionEnd || !isStart) && isEnd) {\n        this.trigger(\"requestAppend\", {\n          key: endKey,\n          nextKey: items[endIndex].key,\n          isVirtual: true,\n        });\n        return true;\n      } else if ((!isDirectionEnd || !isEnd) && isStart) {\n        this.trigger(\"requestPrepend\", {\n          key: startKey,\n          nextKey: items[startIndex].key,\n          isVirtual: true,\n        });\n        return true;\n      }\n    } else if (totalVisibleLength) {\n      const lastItem = totalVisibleItems[totalVisibleLength - 1];\n\n      if (isDirectionEnd) {\n        this.trigger(\"requestAppend\", {\n          nextKey: totalVisibleItems[0].key,\n          isVirtual: true,\n        });\n      } else {\n        this.trigger(\"requestPrepend\", {\n          nextKey: lastItem.key,\n          isVirtual: true,\n        });\n      }\n      return true;\n    }\n    return false;\n  }\n  public setCursors(startCursor: number, endCursor: number) {\n    this.startCursor = startCursor;\n    this.endCursor = endCursor;\n  }\n  public setSize(size: number) {\n    this.size = size;\n  }\n  public getStartCursor() {\n    return this.startCursor;\n  }\n  public getEndCursor() {\n    return this.endCursor;\n  }\n  public isLoading(direction: \"start\" | \"end\") {\n    const startCursor = this.startCursor;\n    const endCursor = this.endCursor;\n    const items = this.items;\n    const firstItem = items[startCursor]!;\n    const lastItem = items[endCursor]!;\n    const length = items.length;\n\n    if (\n      direction === DIRECTION.END\n      && endCursor > -1\n      && endCursor < length - 1\n      && !lastItem.isVirtual\n      && !isFlatOutline(lastItem.startOutline, lastItem.endOutline)\n    ) {\n      return false;\n    }\n    if (\n      direction === DIRECTION.START\n      && startCursor > 0\n      && !firstItem.isVirtual\n      && !isFlatOutline(firstItem.startOutline, firstItem.endOutline)\n    ) {\n      return false;\n    }\n    return true;\n  }\n  public setItems(nextItems: InfiniteItem[]) {\n    this.items = nextItems;\n\n    const itemKeys: Record<string | number, InfiniteItem> = {};\n\n    nextItems.forEach((item) => {\n      itemKeys[item.key] = item;\n    });\n    this.itemKeys = itemKeys;\n  }\n  public syncItems(nextItems: InfiniteItem[]) {\n    const prevItems = this.items;\n    const prevStartCursor = this.startCursor;\n    const prevEndCursor = this.endCursor;\n    const {\n      startCursor: nextStartCursor,\n      endCursor: nextEndCursor,\n    } = getNextCursors(\n      this.items.map((item) => item.key),\n      nextItems.map((item) => item.key),\n      prevStartCursor,\n      prevEndCursor,\n    );\n    // sync items between cursors\n    let isChange = nextEndCursor - nextStartCursor !== prevEndCursor - prevStartCursor\n      || (prevStartCursor === -1 || nextStartCursor === -1);\n\n    if (!isChange) {\n      const prevVisibleItems = prevItems.slice(prevStartCursor, prevEndCursor + 1);\n      const nextVisibleItems = nextItems.slice(nextStartCursor, nextEndCursor + 1);\n      const visibleResult = diff(prevVisibleItems, nextVisibleItems, (item) => item.key);\n\n      isChange = visibleResult.added.length > 0\n        || visibleResult.removed.length > 0\n        || visibleResult.changed.length > 0;\n    }\n    this.setItems(nextItems);\n    this.setCursors(nextStartCursor, nextEndCursor);\n    return isChange;\n  }\n  public getItems() {\n    return this.items;\n  }\n  public getVisibleItems() {\n    const startCursor = this.startCursor;\n    const endCursor = this.endCursor;\n\n    if (startCursor === -1) {\n      return [];\n    }\n    return this.items.slice(startCursor, endCursor + 1);\n  }\n  public getSize() {\n    return this.size;\n  }\n  public getItemByKey(key: string | number) {\n    return this.itemKeys[key];\n  }\n  public getItemPartByKey(partKey: string | number) {\n    let itemPart!: InfiniteItemPart;\n\n    this.items.forEach((item) => {\n      item.parts?.forEach((part) => {\n        if (part.key === partKey) {\n          itemPart = part;\n        }\n      });\n    });\n\n    return itemPart;\n  }\n  public getScrollSize() {\n    const items = this.items;\n    const length = items.length;\n\n    if (!length) {\n      return 0;\n    }\n    return Math.max(0, ...items[length - 1].endOutline);\n  }\n  public getVisibleArea(scrollPos: number, direction = this.options.defaultDirection) {\n    const isDirectionEnd = direction === DIRECTION.END;\n    const visibleItems = this.getRenderedVisibleItems();\n\n    if (!visibleItems.length) {\n      return null;\n    }\n    const visibleItem = visibleItems[isDirectionEnd ? 0 : length - 1];\n    const itemPos = isDirectionEnd\n      ? Math.min(...visibleItem.startOutline)\n      : Math.max(...visibleItem.endOutline);\n    let pos = itemPos;\n    let itemPart!: InfiniteItemPart;\n\n    if (isDirectionEnd) {\n      visibleItems.forEach((item) => {\n        item.parts?.forEach((part) => {\n          if (itemPart && itemPart.pos >= part.pos) {\n            return;\n          }\n          if (pos < part.pos && part.pos <= scrollPos) {\n            itemPart = part;\n            pos = part.pos;\n          }\n        });\n      });\n    } else {\n      visibleItems.forEach((item) => {\n        item.parts?.forEach((part) => {\n          const endPos = part.pos + part.size;\n\n          if (itemPart && itemPart.pos + itemPart.size <= endPos) {\n            return;\n          }\n\n          if (pos > endPos && endPos >= scrollPos) {\n            itemPart = part;\n            pos = endPos;\n          }\n        });\n      });\n    }\n\n    return {\n      item: visibleItem,\n      part: itemPart,\n    };\n  }\n  public getRenderedVisibleItems() {\n    const items = this.getVisibleItems();\n\n    const rendered = items.map(({ startOutline, endOutline }) => {\n      const length = startOutline.length;\n\n      if (length === 0 || length !== endOutline.length) {\n        return false;\n      }\n      return startOutline.some((pos, i) => endOutline[i] !== pos);\n    });\n    const startIndex = rendered.indexOf(true);\n    const endIndex = rendered.lastIndexOf(true);\n\n    return endIndex === -1 ? [] : items.slice(startIndex, endIndex + 1);\n  }\n  public destroy() {\n    this.off();\n    this.startCursor = -1;\n    this.endCursor = -1;\n    this.items = [];\n    this.size = 0;\n  }\n}\n","import Component from \"@egjs/component\";\nimport { diff, DiffResult } from \"@egjs/list-differ\";\nimport { toArray } from \"../utils\";\n\nexport interface RendererItem {\n  key: string | number;\n  renderKey?: string;\n  element?: Element | null;\n}\n\nexport interface OnRendererUpdated<T extends RendererItem = RendererItem> {\n  items: T[];\n  elements: Element[];\n  isChanged: boolean;\n  isItemChanged: boolean;\n  state: Record<string, any>;\n  diffResult: DiffResult<T>;\n}\n\nexport interface OnRendererUpdate {\n  state: Record<string, any>;\n}\nexport interface RendererEvents<T extends RendererItem = RendererItem> {\n  update: OnRendererUpdate;\n  updated: OnRendererUpdated<T>;\n  requestUpdate: OnRendererUpdate;\n}\n\nexport class Renderer<Item extends RendererItem = RendererItem> extends Component<RendererEvents> {\n  protected items: Item[] = [];\n  protected container: Element | null = null;\n  protected rendererKey = 0;\n  private _diffResult: DiffResult<Item>;\n  private _updateTimer = 0;\n  private _state: Record<string, any> = {};\n  private _isItemChanged = false;\n\n  public updateKey() {\n    this.rendererKey = Date.now();\n  }\n\n  public getItems() {\n    return this.items;\n  }\n  public setContainer(container: Element) {\n    this.container = container;\n  }\n  public render(nextItems: Item[], state?: Record<string, any>) {\n    return this.syncItems(nextItems, state);\n  }\n  public update(state: Record<string, any> = {}) {\n    this._state = { ...this._state, ...state };\n    this.trigger(\"update\", {\n      state,\n    });\n\n    clearTimeout(this._updateTimer);\n    this._updateTimer = window.setTimeout(() => {\n      this.trigger(\"requestUpdate\", {\n        state,\n      });\n    });\n  }\n  public updated(nextElements: ArrayLike<Element> = this.container?.children ?? []) {\n    const diffResult = this._diffResult;\n    const isChanged = !!(diffResult.added.length || diffResult.removed.length || diffResult.changed.length);\n    const state = this._state;\n    const isItemChanged = this._isItemChanged;\n    const nextItems = diffResult.list;\n\n\n    this._isItemChanged = false;\n    this._state = {};\n    this.items = nextItems;\n    nextItems.forEach((item, i) => {\n      item.element = nextElements[i];\n    });\n\n\n    this.trigger(\"updated\", {\n      items: nextItems,\n      elements: toArray(nextElements),\n      diffResult: this._diffResult,\n      state,\n      isItemChanged,\n      isChanged,\n    });\n\n    return isChanged;\n  }\n  public syncItems(items: Item[], state: Record<string, any> = {}) {\n    const rendererKey = this.rendererKey;\n    const prevItems = this.items;\n    const nextItems = items.map((item) => ({\n      ...item,\n      renderKey: `${rendererKey}_${item.key}`,\n    }));\n    const result = diff(prevItems, nextItems, (item) => item.renderKey!);\n\n    this._isItemChanged = !!result.added.length || !!result.removed.length || !!result.changed.length;\n    this._state = { ...this._state, ...state };\n    this._diffResult = result;\n\n    return result;\n  }\n  public destroy() {\n    this.off();\n  }\n}\n","import { Renderer, RendererItem } from \"./Renderer\";\n\nexport class VanillaRenderer<Item extends RendererItem = RendererItem> extends Renderer<Item> {\n  public render(nextItems: Item[], state?: Record<string, any>) {\n    const container = this.container!;\n    const result = super.render(nextItems, state);\n    const {\n      prevList,\n      removed,\n      ordered,\n      added,\n      list,\n    } = result;\n    const diffList = [...prevList];\n\n\n    removed.forEach((index) => {\n      diffList.splice(index, 1);\n      container.removeChild(prevList[index].element!);\n    });\n    ordered.forEach(([prevIndex, nextIndex]) => {\n      const item = diffList.splice(prevIndex, 1)[0];\n\n      diffList.splice(nextIndex, 0, item);\n      container.insertBefore(item.element!, diffList[nextIndex + 1]?.element ?? null);\n    });\n    added.forEach((index) => {\n      const item = list[index];\n\n      diffList.splice(index, 0, item);\n      container.insertBefore(item.element!, diffList[index + 1]?.element ?? null);\n    });\n\n    this.updated(container.children);\n    return result;\n  }\n}\n","import { InfiniteGridItem } from \"../InfiniteGridItem\";\nimport { convertHTMLtoElement } from \"../utils\";\nimport { RendererItem } from \"./Renderer\";\nimport { VanillaRenderer } from \"./VanillaRenderer\";\n\nexport interface GridRendererItem extends RendererItem {\n  orgItem: InfiniteGridItem;\n}\n\nexport class VanillaGridRenderer extends VanillaRenderer<GridRendererItem> {\n  public syncItems(nextItems: GridRendererItem[]) {\n    const result = super.syncItems(nextItems);\n    const {\n      added,\n      list,\n    } = result;\n    added.forEach((index) => {\n      const orgItem = nextItems[index].orgItem;\n\n      if (orgItem.html && !orgItem.element) {\n        orgItem.element = convertHTMLtoElement(orgItem.html)[0];\n      }\n      list[index].element = orgItem.element!;\n    });\n\n    return result;\n  }\n}\n","import { findTarget, Ref } from \"@cfcs/core\";\nimport Component, { ComponentEvent } from \"@egjs/component\";\nimport { CONTAINER_CLASS_NAME, IS_IOS } from \"./consts\";\nimport { OnChangeScroll } from \"./types\";\nimport { isWindow, toArray } from \"./utils\";\n\nexport interface ScrollManagerOptions {\n  scrollContainer?: HTMLElement | string | Ref<HTMLElement> | null;\n  container?: boolean | HTMLElement | string | Ref<HTMLElement>;\n  containerTag?: string;\n  horizontal?: boolean;\n}\n\nexport interface ScrollManagerStatus {\n  contentSize: number;\n  scrollOffset: number;\n  prevScrollPos: number;\n}\n\n\nexport interface ScrollManagerEvents {\n  scroll: OnChangeScroll;\n}\n\nexport class ScrollManager extends Component<ScrollManagerEvents> {\n  public options: Required<ScrollManagerOptions>;\n  protected prevScrollPos: number | null = null;\n  protected eventTarget: HTMLElement | Window;\n  protected scrollOffset = 0;\n  protected contentSize = 0;\n  protected container: HTMLElement;\n  protected scrollContainer: HTMLElement;\n  private _orgCSSText: string;\n  private _isScrollIssue = IS_IOS;\n  private _isCreateElement: boolean;\n\n  constructor(\n    protected wrapper: HTMLElement,\n    options: ScrollManagerOptions,\n  ) {\n    super();\n    this.options = {\n      container: false,\n      containerTag: \"div\",\n      horizontal: false,\n      scrollContainer: null,\n      ...options,\n    };\n\n    this._init();\n  }\n  public getWrapper() {\n    return this.wrapper;\n  }\n  public getContainer() {\n    return this.container;\n  }\n  public getScrollContainer() {\n    return this.scrollContainer;\n  }\n  public getScrollOffset() {\n    return this.scrollOffset;\n  }\n  public getContentSize() {\n    return this.contentSize;\n  }\n  public getRelativeScrollPos() {\n    return (this.prevScrollPos || 0) - this.scrollOffset;\n  }\n  public getScrollPos() {\n    return this.prevScrollPos;\n  }\n  public setScrollPos(pos: number) {\n    this.prevScrollPos = pos;\n  }\n  public getOrgScrollPos() {\n    const eventTarget = this.eventTarget;\n    const horizontal = this.options.horizontal;\n\n    const prop = `scroll${horizontal ? \"Left\" : \"Top\"}` as \"scrollLeft\" | \"scrollTop\";\n\n    if (isWindow(eventTarget)) {\n      return window[horizontal ? \"pageXOffset\" : \"pageYOffset\"]\n        || document.documentElement[prop] || document.body[prop];\n    } else {\n      return eventTarget[prop];\n    }\n  }\n  public setStatus(status: ScrollManagerStatus) {\n    this.contentSize = status.contentSize;\n    this.scrollOffset = status.scrollOffset;\n    this.prevScrollPos = status.prevScrollPos;\n\n    this.scrollTo(this.prevScrollPos);\n  }\n  public getStatus(): ScrollManagerStatus {\n    return {\n      contentSize: this.contentSize,\n      scrollOffset: this.scrollOffset,\n      prevScrollPos: this.prevScrollPos!,\n    };\n  }\n  public scrollTo(pos: number) {\n    const eventTarget = this.eventTarget;\n    const horizontal = this.options.horizontal;\n    const [x, y] = horizontal ? [pos, 0] : [0, pos];\n\n    if (isWindow(eventTarget)) {\n      eventTarget.scroll(x, y);\n    } else {\n      eventTarget.scrollLeft = x;\n      eventTarget.scrollTop = y;\n    }\n  }\n  public scrollBy(pos: number) {\n    if (!pos) {\n      return;\n    }\n    const eventTarget = this.eventTarget;\n    const horizontal = this.options.horizontal;\n    const [x, y] = horizontal ? [pos, 0] : [0, pos];\n\n\n    this.prevScrollPos! += pos;\n\n    if (isWindow(eventTarget)) {\n      eventTarget.scrollBy(x, y);\n    } else {\n      eventTarget.scrollLeft += x;\n      eventTarget.scrollTop += y;\n    }\n  }\n  public resize() {\n    const scrollContainer = this.scrollContainer;\n    const horizontal = this.options.horizontal;\n    const isBody = scrollContainer === document.body;\n    const scrollContainerRect = isBody\n      ? { top: 0, left: 0 }\n      : scrollContainer.getBoundingClientRect();\n    const containerRect = this.container.getBoundingClientRect();\n\n    this.scrollOffset = (this.getOrgScrollPos()! || 0) + (horizontal\n      ? containerRect.left - scrollContainerRect.left\n      : containerRect.top - scrollContainerRect.top);\n\n    if (isBody) {\n      this.contentSize = horizontal ? window.innerWidth : window.innerHeight;\n    } else {\n      this.contentSize = horizontal ? scrollContainer.offsetWidth : scrollContainer.offsetHeight;\n    }\n  }\n  public destroy() {\n    const container = this.container;\n\n    this.eventTarget.removeEventListener(\"scroll\", this._onCheck);\n\n    if (this._isCreateElement) {\n      const scrollContainer = this.scrollContainer;\n\n      const fragment = document.createDocumentFragment();\n      const childNodes = toArray(container.childNodes);\n\n      scrollContainer.removeChild(container);\n      childNodes.forEach((childNode) => {\n        fragment.appendChild(childNode);\n      });\n      scrollContainer.appendChild(fragment);\n    } else if (this.options.container) {\n      container.style.cssText = this._orgCSSText;\n    }\n  }\n  private _init() {\n    const {\n      container: containerOption,\n      containerTag,\n      horizontal,\n      scrollContainer: scrollContainerOption,\n    } = this.options;\n    const wrapper = this.wrapper;\n    let scrollContainer = wrapper;\n    let container = wrapper;\n    let containerCSSText = \"\";\n\n    if (!containerOption) {\n      scrollContainer = findTarget(scrollContainerOption) || document.body;\n      containerCSSText = container.style.cssText;\n    } else {\n      if (containerOption === true) {\n        // Create Container\n        container = document.createElement(containerTag) as HTMLElement;\n\n        container.style.position = \"relative\";\n        container.className = CONTAINER_CLASS_NAME;\n        const childNodes = toArray(scrollContainer.childNodes);\n\n        childNodes.forEach((childNode) => {\n          container.appendChild(childNode);\n        });\n        scrollContainer.appendChild(container);\n\n        this._isCreateElement = true;\n      } else {\n        // Find Container\n        container = findTarget(containerOption)!;\n      }\n      containerCSSText = container.style.cssText;\n\n      const style = scrollContainer.style;\n\n      [style.overflowX, style.overflowY] = horizontal ? [\"scroll\", \"hidden\"] : [\"hidden\", \"scroll\"];\n\n      if (horizontal) {\n        container.style.height = \"100%\";\n      }\n    }\n    const eventTarget = scrollContainer === document.body ? window : scrollContainer;\n\n    eventTarget.addEventListener(\"scroll\", this._onCheck);\n    this._orgCSSText = containerCSSText;\n    this.container = container;\n    this.scrollContainer = scrollContainer;\n    this.eventTarget = eventTarget;\n    this.resize();\n    this.setScrollPos(this.getOrgScrollPos());\n  }\n  private _onCheck = () => {\n    const prevScrollPos = this.getScrollPos();\n    const nextScrollPos = this.getOrgScrollPos();\n\n    this.setScrollPos(nextScrollPos);\n\n    if (prevScrollPos === null || (this._isScrollIssue && nextScrollPos === 0) || prevScrollPos === nextScrollPos) {\n      nextScrollPos && (this._isScrollIssue = false);\n      return;\n    }\n    this._isScrollIssue = false;\n    this.trigger(new ComponentEvent(\"scroll\", {\n      direction: prevScrollPos < nextScrollPos ? \"end\" : \"start\",\n      scrollPos: nextScrollPos,\n      relativeScrollPos: this.getRelativeScrollPos(),\n    }));\n  }\n}\n","import Component, { ComponentEvent } from \"@egjs/component\";\nimport Grid, {\n  ContainerManager,\n  DEFAULT_GRID_OPTIONS,\n  Properties,\n  RenderOptions,\n  MOUNT_STATE,\n  OnContentError,\n  ItemRenderer,\n  GridItem,\n  ResizeWatcherResizeEvent,\n  getUpdatedItems,\n} from \"@egjs/grid\";\nimport {\n  DIRECTION,\n  GROUP_TYPE,\n  INFINITEGRID_EVENTS, INFINITEGRID_PROPERTY_TYPES,\n  INVISIBLE_POS,\n  ITEM_TYPE, STATUS_TYPE,\n} from \"./consts\";\nimport { GroupManager } from \"./GroupManager\";\nimport {\n  Infinite,\n  InfiniteItem,\n  InfiniteItemPart,\n  OnInfiniteChange,\n  OnInfiniteRequestAppend,\n  OnInfiniteRequestPrepend,\n} from \"./Infinite\";\nimport { InfiniteGridItem, InfiniteGridItemStatus } from \"./InfiniteGridItem\";\nimport { OnRendererUpdated } from \"./Renderer/Renderer\";\nimport { GridRendererItem, VanillaGridRenderer } from \"./Renderer/VanillaGridRenderer\";\nimport { ScrollManager } from \"./ScrollManager\";\nimport {\n  InfiniteGridEvents, InfiniteGridGroup,\n  InfiniteGridInsertedItems, InfiniteGridItemInfo,\n  InfiniteGridOptions,\n  InfiniteGridStatus,\n  InsertedPlaceholdersResult,\n  OnPickedRenderComplete,\n  OnRequestInsert,\n  OnChangeScroll,\n} from \"./types\";\nimport {\n  InfiniteGridGetterSetter, toArray, convertInsertedItems, findIndex,\n  findLastIndex, isString,\n} from \"./utils\";\n\n\n/**\n * A module used to arrange items including content infinitely according to layout type. With this module, you can implement various layouts composed of different items whose sizes vary. It guarantees performance by maintaining the number of DOMs the module is handling under any circumstance\n * @ko 콘텐츠가 있는 아이템을 레이아웃 타입에 따라 무한으로 배치하는 모듈. 다양한 크기의 아이템을 다양한 레이아웃으로 배치할 수 있다. 아이템의 개수가 계속 늘어나도 모듈이 처리하는 DOM의 개수를 일정하게 유지해 최적의 성능을 보장한다\n * @extends Component\n * @support {\"ie\": \"9+(with polyfill)\", \"ch\" : \"latest\", \"ff\" : \"latest\",  \"sf\" : \"latest\", \"edge\" : \"latest\", \"ios\" : \"7+\", \"an\" : \"4.X+\"}\n * @example\n```html\n<ul id=\"grid\">\n  <li class=\"card\">\n    <div>test1</div>\n  </li>\n  <li class=\"card\">\n    <div>test2</div>\n  </li>\n  <li class=\"card\">\n    <div>test3</div>\n  </li>\n  <li class=\"card\">\n    <div>test4</div>\n  </li>\n  <li class=\"card\">\n    <div>test5</div>\n  </li>\n  <li class=\"card\">\n    <div>test6</div>\n  </li>\n</ul>\n<script>\nimport { MasonryInfiniteGrid } from \"@egjs/infinitegrid\";\nvar some = new MasonryInfiniteGrid(\"#grid\").on(\"renderComplete\", function(e) {\n  // ...\n});\n// If you already have items in the container, call \"layout\" method.\nsome.renderItems();\n</script>\n```\n */\n@InfiniteGridGetterSetter\nclass InfiniteGrid<Options extends InfiniteGridOptions = InfiniteGridOptions> extends Component<InfiniteGridEvents> {\n  public static defaultOptions = {\n    ...DEFAULT_GRID_OPTIONS,\n    container: false,\n    containerTag: \"div\",\n    renderer: null,\n    threshold: 100,\n    useRecycle: true,\n    scrollContainer: null,\n    appliedItemChecker: (() => false) as (item: InfiniteGridItem, grid: Grid) => boolean,\n  } as Required<InfiniteGridOptions>;\n  public static propertyTypes = INFINITEGRID_PROPERTY_TYPES;\n  protected wrapperElement: HTMLElement;\n  protected scrollManager: ScrollManager;\n  protected itemRenderer: ItemRenderer;\n  protected containerManager: ContainerManager;\n  protected infinite: Infinite;\n  protected groupManager: GroupManager;\n  protected options: Required<Options>;\n  private _waitType: \"\" | \"start\" | \"end\" = \"\";\n  /**\n   * @param - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n   * @param - The option object of the InfiniteGrid module <ko>eg.InfiniteGrid 모듈의 옵션 객체</ko>\n   */\n  constructor(wrapper: HTMLElement | string, options: Options) {\n    super();\n    this.options = {\n      ...((this.constructor as typeof InfiniteGrid).defaultOptions as Required<Options>),\n      renderer: new VanillaGridRenderer().on(\"requestUpdate\", () => this._render()),\n      ...options,\n    };\n\n    const {\n      gridConstructor,\n      containerTag,\n      container,\n      renderer,\n      threshold,\n      useRecycle,\n      scrollContainer,\n      appliedItemChecker,\n      ...gridOptions\n    } = this.options;\n    // options.container === false, wrapper = container, scrollContainer = document.body\n    // options.container === true, wrapper = scrollContainer, container = wrapper's child\n    // options.container === string,\n    const {\n      horizontal,\n      attributePrefix,\n      useTransform,\n      percentage,\n      isConstantSize,\n      isEqualSize,\n      autoResize,\n      useResizeObserver,\n      resizeDebounce,\n      maxResizeDebounce,\n      defaultDirection,\n      useRoundedSize,\n    } = gridOptions;\n    const wrapperElement = isString(wrapper) ? document.querySelector(wrapper) as HTMLElement : wrapper;\n    const scrollManager = new ScrollManager(wrapperElement, {\n      scrollContainer,\n      container,\n      containerTag,\n      horizontal,\n    }).on({\n      scroll: this._onScroll,\n    });\n    const containerElement = scrollManager.getContainer();\n    const containerManager = new ContainerManager(containerElement, {\n      horizontal,\n      autoResize,\n      resizeDebounce,\n      maxResizeDebounce,\n      useResizeObserver,\n    }).on(\"resize\", this._onResize);\n    const itemRenderer = new ItemRenderer({\n      attributePrefix,\n      horizontal,\n      useTransform,\n      percentage,\n      isEqualSize,\n      isConstantSize,\n      useRoundedSize,\n    });\n    const infinite = new Infinite({\n      defaultDirection,\n      useRecycle,\n      threshold,\n    }).on({\n      \"change\": this._onChange,\n      \"requestAppend\": this._onRequestAppend,\n      \"requestPrepend\": this._onRequestPrepend,\n    });\n\n    infinite.setSize(scrollManager.getContentSize());\n    const groupManager = new GroupManager(containerElement, {\n      appliedItemChecker: appliedItemChecker!,\n      gridConstructor: gridConstructor!,\n      externalItemRenderer: itemRenderer,\n      externalContainerManager: containerManager,\n      gridOptions,\n    });\n\n    groupManager.on({\n      \"renderComplete\": this._onRenderComplete,\n      \"contentError\": this._onContentError,\n    });\n\n    renderer!.setContainer(containerElement);\n    renderer!.on(\"updated\", this._onRendererUpdated);\n\n    this.itemRenderer = itemRenderer;\n    this.groupManager = groupManager;\n    this.wrapperElement = wrapperElement;\n    this.scrollManager = scrollManager;\n    this.containerManager = containerManager;\n    this.infinite = infinite;\n\n    this.containerManager.resize();\n  }\n  /**\n   * Rearrange items to fit the grid and render them. When rearrange is complete, the `renderComplete` event is fired.\n   * @ko grid에 맞게 아이템을 재배치하고 렌더링을 한다. 배치가 완료되면 `renderComplete` 이벤트가 발생한다.\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   * @example\n   * ```ts\n   * import { MasonryInfiniteGrid } from \"@egjs/infinitegrid\";\n   * const grid = new MasonryInfiniteGrid();\n   *\n   * grid.on(\"renderComplete\", e => {\n   *   console.log(e);\n   * });\n   * grid.renderItems();\n   * ```\n   */\n  public renderItems(options: RenderOptions = {}) {\n    this._renderItems(options);\n    return this;\n  }\n  /**\n   * Returns the wrapper element specified by the user.\n   * @ko 컨테이너 엘리먼트를 반환한다.\n   */\n  public getWrapperElement() {\n    return this.scrollManager.getWrapper();\n  }\n  /**\n   * Returns the container element corresponding to the scroll area.\n   * @ko 스크롤 영역에 해당하는 컨테이너 엘리먼트를 반환한다.\n   */\n  public getScrollContainerElement() {\n    return this.scrollManager.getScrollContainer();\n  }\n  /**\n   * Returns the container element containing item elements.\n   * @ko 아이템 엘리먼트들을 담긴 컨테이너 엘리먼트를 반환한다.\n   */\n  public getContainerElement() {\n    return this.scrollManager.getContainer();\n  }\n  /**\n   * When items change, it synchronizes and renders items.\n   * @ko items가 바뀐 경우 동기화를 하고 렌더링을 한다.\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  public syncItems(items: InfiniteGridItemInfo[]): this {\n    this.groupManager.syncItems(items);\n    this._syncGroups();\n\n    return this;\n  }\n  /**\n   * Change the currently visible groups.\n   * @ko 현재 보이는 그룹들을 바꾼다.\n   * @param - first index of visible groups. <ko>보이는 그룹의 첫번째 index.</ko>\n   * @param - last index of visible groups. <ko>보이는 그룹의 마지막 index.</ko>\n   * @param - Whether the first rendering has already been done. <ko>첫 렌더링이 이미 되어있는지 여부.</ko>\n   */\n  public setCursors(startCursor: number, endCursor: number, useFirstRender?: boolean): this {\n    this.groupManager.setCursors(startCursor, endCursor);\n    this.infinite.setCursors(startCursor, endCursor);\n\n    if (useFirstRender) {\n      this.getVisibleItems().forEach((item) => {\n        if (item.cssRect.top === INVISIBLE_POS) {\n          item.cssRect = {};\n        }\n      });\n      this._syncItems();\n    } else {\n      this._update();\n      this._checkEndLoading();\n    }\n    return this;\n  }\n  /**\n   * Returns the first index of visible groups.\n   * @ko 보이는 그룹들의 첫번째 index를 반환한다.\n   */\n  public getStartCursor(): number {\n    return this.infinite.getStartCursor();\n  }\n  /**\n   * Returns the last index of visible groups.\n   * @ko 보이는 그룹들의 마지막 index를 반환한다.\n   */\n  public getEndCursor(): number {\n    return this.infinite.getEndCursor();\n  }\n  /**\n   * Add items at the bottom(right) of the grid.\n   * @ko 아이템들을 grid 아래(오른쪽)에 추가한다.\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```js\n   * ig.append(`<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.append([`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.append([HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  public append(items: InfiniteGridInsertedItems, groupKey?: string | number): this {\n    return this.insert(-1, items, groupKey);\n  }\n  /**\n   * Add items at the top(left) of the grid.\n   * @ko 아이템들을 grid 위(왼쪽)에 추가한다.\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * ig.prepend(`<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.prepend([`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.prepend([HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  public prepend(items: InfiniteGridInsertedItems, groupKey?: string | number): this {\n    return this.insert(0, items, groupKey);\n  }\n  /**\n   * Add items to a specific index.\n   * @ko 아이템들을 특정 index에 추가한다.\n   * @param - index to add <ko>추가하기 위한 index</ko>\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * ig.insert(2, `<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.insert(3, [`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.insert(4, [HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  public insert(index: number, items: InfiniteGridInsertedItems, groupKey?: string | number): this {\n    const nextItemInfos: InfiniteGridItemInfo[] = this.groupManager.getGroupItems();\n    const itemInfos = convertInsertedItems(items, groupKey);\n\n    if (index === -1) {\n      nextItemInfos.push(...itemInfos);\n    } else {\n      nextItemInfos.splice(index, 0, ...itemInfos);\n    }\n    return this.syncItems(nextItemInfos);\n  }\n  /**\n   * Add items based on group index.\n   * @ko group의 index 기준으로 item들을 추가한다.\n   * @param - group index to add <ko>추가하기 위한 group의 index</ko>\n   * @param - items to be added <ko>추가할 아이템들</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   * @return - An instance of a module itself<ko>모듈 자신의 인스턴스</ko>\n   * @example\n   * ```ts\n   * ig.insertByGroupIndex(2, `<div class=\"item\">test1</div><div class=\"item\">test2</div>`);\n   * ig.insertByGroupIndex(3, [`<div class=\"item\">test1</div>`, `<div class=\"item\">test2</div>`]);\n   * ig.insertByGroupIndex(4, [HTMLElement1, HTMLElement2]);\n   * ```\n   */\n  public insertByGroupIndex(groupIndex: number, items: InfiniteGridInsertedItems, groupKey?: string | number): this {\n    const nextGroupInfos: InfiniteGridGroup[] = this.groupManager.getGroups();\n    const rightGroup = nextGroupInfos[groupIndex];\n\n    if (!rightGroup) {\n      return this.append(items, groupKey);\n    }\n    const nextItemInfos: InfiniteGridItemInfo[] = this.groupManager.getGroupItems();\n    const rightGroupKey = rightGroup.groupKey;\n    const rightItemIndex = findIndex(nextItemInfos, (item) => item.groupKey === rightGroupKey);\n\n    return this.insert(rightItemIndex, items, groupKey);\n  }\n  /**\n   * Returns the current state of a module such as location information. You can use the setStatus() method to restore the information returned through a call to this method.\n   * @ko 아이템의 위치 정보 등 모듈의 현재 상태 정보를 반환한다. 이 메서드가 반환한 정보를 저장해 두었다가 setStatus() 메서드로 복원할 수 있다\n   * @param - STATUS_TYPE.NOT_REMOVE = Get all information about items. STATUS_TYPE.REMOVE_INVISIBLE_ITEMS = Get information on visible items only. STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS = Compress invisible items. You can replace it with a placeholder. STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS = Compress invisible groups. <ko> STATUS_TYPE.NOT_REMOVE = 모든 아이템들의 정보를 가져온다. STATUS_TYPE.REMOVE_INVISIBLE_ITEMS = 보이는 아이템들의 정보만 가져온다. STATUS_TYPE.MINIMIZE_INVISIBLE_ITEMS = 안보이는 아이템들을 압축한다. placeholder로 대체가 가능하다. STATUS_TYPE.MINIMIZE_INVISIBLE_GROUPS = 안보이는 그룹을 압축한다.</ko>\n   * @param - Whether to include items corresponding to placeholders. <ko>placeholder에 해당하는 아이템들을 포함할지 여부.</ko>\n   */\n  public getStatus(type?: STATUS_TYPE, includePlaceholders?: boolean): InfiniteGridStatus {\n    return {\n      containerManager: this.containerManager.getStatus(),\n      itemRenderer: this.itemRenderer.getStatus(),\n      groupManager: this.groupManager.getGroupStatus(type, includePlaceholders),\n      scrollManager: this.scrollManager.getStatus(),\n    };\n  }\n\n  /**\n   * You can set placeholders to restore status or wait for items to be added.\n   * @ko status 복구 또는 아이템 추가 대기를 위한 placeholder를 설정할 수 있다.\n   * @param - The placeholder status. <ko>placeholder의 status</ko>\n   */\n  public setPlaceholder(info: Partial<InfiniteGridItemStatus> | null): this {\n    this.groupManager.setPlaceholder(info);\n    return this;\n  }\n  /**\n   * You can set placeholders to restore status or wait for items to be added.\n   * @ko status 복구 또는 아이템 추가 대기를 위한 placeholder를 설정할 수 있다.\n   * @param - The placeholder status. <ko>placeholder의 status</ko>\n   */\n  public setLoading(info: Partial<InfiniteGridItemStatus> | null): this {\n    this.groupManager.setLoading(info);\n    return this;\n  }\n  /**\n   * Add the placeholder at the end.\n   * @ko placeholder들을 마지막에 추가한다.\n   * @param - Items that correspond to placeholders. If it is a number, it duplicates the number of copies. <ko>placeholder에 해당하는 아이템들. 숫자면 갯수만큼 복제를 한다.</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   */\n  public appendPlaceholders(\n    items: number | InfiniteGridItemStatus[],\n    groupKey?: string | number,\n  ): InsertedPlaceholdersResult {\n    const result = this.groupManager.appendPlaceholders(items, groupKey);\n\n    this._syncGroups(true);\n    return {\n      ...result,\n      remove: () => {\n        this.removePlaceholders({ groupKey: result.group.groupKey });\n      },\n    };\n  }\n  /**\n   * Add the placeholder at the start.\n   * @ko placeholder들을 처음에 추가한다.\n   * @param - Items that correspond to placeholders. If it is a number, it duplicates the number of copies. <ko>placeholder에 해당하는 아이템들. 숫자면 갯수만큼 복제를 한다.</ko>\n   * @param - The group key to be configured in items. It is automatically generated by default. <ko>추가할 아이템에 설정할 그룹 키. 생략하면 값이 자동으로 생성된다.</ko>\n   */\n  public prependPlaceholders(\n    items: number | InfiniteGridItemStatus[],\n    groupKey?: string | number,\n  ): InsertedPlaceholdersResult {\n    const result = this.groupManager.prependPlaceholders(items, groupKey);\n\n    this._syncGroups(true);\n    return {\n      ...result,\n      remove: () => {\n        this.removePlaceholders({ groupKey: result.group.groupKey });\n      },\n    };\n  }\n\n  /**\n   * Remove placeholders\n   * @ko placeholder들을 삭제한다.\n   * @param type - Remove the placeholders corresponding to the groupkey. When \"start\" or \"end\", remove all placeholders in that direction. <ko>groupkey에 해당하는 placeholder들을 삭제한다. \"start\" 또는 \"end\" 일 때 해당 방향의 모든 placeholder들을 삭제한다.</ko>\n   */\n  public removePlaceholders(type: \"start\" | \"end\" | { groupKey: string | number }) {\n    this.groupManager.removePlaceholders(type);\n    this._syncGroups(true);\n  }\n\n  /**\n   * Sets the status of the InfiniteGrid module with the information returned through a call to the getStatus() method.\n   * @ko getStatus() 메서드가 저장한 정보로 InfiniteGrid 모듈의 상태를 설정한다.\n   * @param - status object of the InfiniteGrid module. <ko>InfiniteGrid 모듈의 status 객체.</ko>\n   * @param - Whether the first rendering has already been done. <ko>첫 렌더링이 이미 되어있는지 여부.</ko>\n   */\n  public setStatus(status: InfiniteGridStatus, useFirstRender?: boolean): this {\n    this.itemRenderer.setStatus(status.itemRenderer);\n    this.containerManager.setStatus(status.containerManager);\n    this.scrollManager.setStatus(status.scrollManager);\n    const groupManager = this.groupManager;\n    const prevInlineSize = this.containerManager.getInlineSize();\n\n    groupManager.setGroupStatus(status.groupManager);\n    this._syncInfinite();\n    this.infinite.setCursors(groupManager.getStartCursor(), groupManager.getEndCursor());\n\n    this._getRenderer().updateKey();\n\n    const state = {\n      isResize: this.containerManager.getInlineSize() !== prevInlineSize,\n      isRestore: true,\n    };\n    if (useFirstRender) {\n      this._syncItems(state);\n    } else {\n      this._update(state);\n    }\n    return this;\n  }\n  /**\n   * Removes the group corresponding to index.\n   * @ko index에 해당하는 그룹을 제거 한다.\n   */\n  public removeGroupByIndex(index: number): this {\n    const nextGroups = this.getGroups();\n\n    return this.removeGroupByKey(nextGroups[index].groupKey);\n  }\n  /**\n   * Removes the group corresponding to key.\n   * @ko key에 해당하는 그룹을 제거 한다.\n   */\n  public removeGroupByKey(key: number | string): this {\n    const nextItemInfos = this.getItems();\n\n    const firstIndex = findIndex(nextItemInfos, (item) => item.groupKey === key);\n    const lastIndex = findLastIndex(nextItemInfos, (item) => item.groupKey === key);\n\n    if (firstIndex === -1) {\n      return this;\n    }\n    nextItemInfos.splice(firstIndex, lastIndex - firstIndex + 1);\n    return this.syncItems(nextItemInfos);\n  }\n  /**\n   * Removes the item corresponding to index.\n   * @ko index에 해당하는 아이템을 제거 한다.\n   */\n  public removeByIndex(index: number): this {\n    const nextItemInfos = this.getItems(true);\n\n    nextItemInfos.splice(index, 1);\n\n    return this.syncItems(nextItemInfos);\n  }\n  /**\n   * Removes the item corresponding to key.\n   * @ko key에 해당하는 아이템을 제거 한다.\n   */\n  public removeByKey(key: string | number): this {\n    const nextItemInfos = this.getItems(true);\n    const index = findIndex(nextItemInfos, (item) => item.key === key);\n\n    return this.removeByIndex(index);\n  }\n  /**\n   * Update the size of the items and render them.\n   * @ko 아이템들의 사이즈를 업데이트하고 렌더링을 한다.\n   * @param - Items to be updated. <ko>업데이트할 아이템들.</ko>\n   * @param - Options for rendering. <ko>렌더링을 하기 위한 옵션.</ko>\n   */\n  public updateItems(items?: InfiniteGridItem[], options: RenderOptions = {}) {\n    this.groupManager.updateItems(items, options);\n    return this;\n  }\n  /**\n   * Return all items of InfiniteGrid.\n   * @ko InfiniteGrid의 모든 아이템들을 반환한다.\n   * @param - Whether to include items corresponding to placeholders. <ko>placeholder에 해당하는 아이템들을 포함할지 여부.</ko>\n   */\n  public getItems(includePlaceholders?: boolean): InfiniteGridItem[] {\n    return this.groupManager.getGroupItems(includePlaceholders);\n  }\n  /**\n   * Return visible items of InfiniteGrid.\n   * @ko InfiniteGrid의 보이는 아이템들을 반환한다.\n   * @param - Whether to include items corresponding to placeholders. <ko>placeholder에 해당하는 아이템들을 포함할지 여부.</ko>\n   */\n  public getVisibleItems(includePlaceholders?: boolean): InfiniteGridItem[] {\n    return this.groupManager.getVisibleItems(includePlaceholders);\n  }\n\n  /**\n   * Return rendering items of InfiniteGrid.\n   * @ko InfiniteGrid의 렌더링 아이템들을 반환한다.\n   */\n  public getRenderingItems(): InfiniteGridItem[] {\n    return this.groupManager.getRenderingItems();\n  }\n  /**\n   * Return all groups of InfiniteGrid.\n   * @ko InfiniteGrid의 모든 그룹들을 반환한다.\n   * @param - Whether to include groups corresponding to placeholders. <ko>placeholder에 해당하는 그룹들을 포함할지 여부.</ko>\n   */\n  public getGroups(includePlaceholders?: boolean): InfiniteGridGroup[] {\n    return this.groupManager.getGroups(includePlaceholders);\n  }\n  /**\n   * Return visible groups of InfiniteGrid.\n   * @ko InfiniteGrid의 보이는 그룹들을 반환한다.\n   * @param - Whether to include groups corresponding to placeholders. <ko>placeholder에 해당하는 그룹들을 포함할지 여부.</ko>\n   */\n  public getVisibleGroups(includePlaceholders?: boolean): InfiniteGridGroup[] {\n    return this.groupManager.getVisibleGroups(includePlaceholders);\n  }\n  /**\n   * Set to wait to request data.\n   * @ko 데이터를 요청하기 위해 대기 상태로 설정한다.\n   * @param direction - direction in which data will be added. <ko>데이터를 추가하기 위한 방향.</ko>\n   */\n  public wait(direction: \"start\" | \"end\" = DIRECTION.END) {\n    this._waitType = direction;\n    this._checkStartLoading(direction);\n  }\n  /**\n   * When the data request is complete, it is set to ready state.\n   * @ko 데이터 요청이 끝났다면 준비 상태로 설정한다.\n   * @param - <ko>데이터가 존재하지 않으면 loading bar를 즉시 제거 한다.</ko>\n   */\n  public ready(hasNoData?: boolean) {\n    this._waitType = \"\";\n\n    if (hasNoData) {\n      this.groupManager.waitEndLoading();\n\n      if (this.groupManager.endLoading()) {\n        this._update();\n      }\n    }\n  }\n  /**\n   * Returns whether it is set to wait to request data.\n   * @ko 데이터를 요청하기 위해 대기 상태로 설정되어 있는지 여부를 반환한다.\n   */\n  public isWait() {\n    return !!this._waitType;\n  }\n  /**\n   * Releases the instnace and events and returns the CSS of the container and elements.\n   * @ko 인스턴스와 이벤트를 해제하고 컨테이너와 엘리먼트들의 CSS를 되돌린다.\n   */\n  public destroy(): void {\n    this.off();\n    this._getRenderer().destroy();\n    this.containerManager.destroy();\n    this.groupManager.destroy();\n    this.scrollManager.destroy();\n    this.infinite.destroy();\n  }\n\n  private _getRenderer() {\n    return this.options.renderer!;\n  }\n  private _getRendererItems() {\n    return this.getRenderingItems().map((item) => {\n      return {\n        element: item.element,\n        key: `${item.type}_${item.key}`,\n        orgItem: item,\n      };\n    });\n  }\n  private _syncItems(state?: Record<string, any>): void {\n    this._getRenderer().syncItems(this._getRendererItems(), state);\n  }\n  private _render(state?: Record<string, any>): void {\n    this._getRenderer().render(this._getRendererItems(), state);\n  }\n  private _update(state: Record<string, any> = {}): void {\n    this._getRenderer().update(state);\n  }\n  private _resizeScroll() {\n    const scrollManager = this.scrollManager;\n\n    scrollManager.resize();\n\n    this.infinite.setSize(scrollManager.getContentSize());\n  }\n  private _syncGroups(isUpdate?: boolean) {\n    const infinite = this.infinite;\n    const scrollManager = this.scrollManager;\n\n    if (!scrollManager.getContentSize()) {\n      this._resizeScroll();\n    }\n    this._syncInfinite();\n    this.groupManager.setCursors(infinite.getStartCursor(), infinite.getEndCursor());\n    if (isUpdate) {\n      this._update();\n    } else {\n      this._render();\n    }\n  }\n  private _syncInfinite() {\n    this.infinite.syncItems(this.getGroups(true).map(({ groupKey, grid, type }) => {\n      const outlines = grid.getOutlines();\n\n      return {\n        key: groupKey,\n        isVirtual: type === GROUP_TYPE.VIRTUAL,\n        startOutline: outlines.start,\n        endOutline: outlines.end,\n        parts: grid.getItems().map((item) => {\n          return {\n            key: item.key,\n            pos: item.computedContentPos,\n            size: item.computedContentSize,\n          };\n        }),\n      };\n    }));\n  }\n  private _scroll() {\n    this.infinite.scroll(this.scrollManager.getRelativeScrollPos());\n  }\n  private _onScroll = ({ direction, scrollPos, relativeScrollPos }: OnChangeScroll): void => {\n    this._scroll();\n    /**\n     * This event is fired when scrolling.\n     * @ko 스크롤하면 발생하는 이벤트이다.\n     * @event InfiniteGrid#changeScroll\n     * @param {InfiniteGrid.OnChangeScroll} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     */\n    this.trigger(new ComponentEvent(INFINITEGRID_EVENTS.CHANGE_SCROLL, {\n      direction,\n      scrollPos,\n      relativeScrollPos,\n    }));\n  }\n\n  private _onChange = (e: OnInfiniteChange): void => {\n    this.setCursors(e.nextStartCursor, e.nextEndCursor);\n  }\n  private _onRendererUpdated = (e: OnRendererUpdated<GridRendererItem>): void => {\n    const renderedItems = e.items;\n\n    renderedItems.forEach((item) => {\n      // set grid element\n      const gridItem = item.orgItem;\n\n      gridItem.element = item.element as HTMLElement;\n    });\n\n    if (!e.isChanged) {\n      this._checkEndLoading();\n      this._scroll();\n      return;\n    }\n\n    const {\n      added,\n      removed,\n      prevList,\n      list,\n    } = e.diffResult;\n\n    removed.forEach((index) => {\n      const orgItem = prevList[index].orgItem;\n\n      if (orgItem.mountState !== MOUNT_STATE.UNCHECKED) {\n        orgItem.mountState = MOUNT_STATE.UNMOUNTED;\n      }\n    });\n\n\n    const horizontal = this.options.horizontal;\n    const addedItems = added.map((index) => {\n      const gridItem = list[index].orgItem;\n      const element = gridItem.element!;\n\n      if (gridItem.type === ITEM_TYPE.VIRTUAL) {\n        const cssRect = { ...gridItem.cssRect };\n        const rect = gridItem.rect;\n\n        if (!cssRect.width && rect.width) {\n          cssRect.width = rect.width;\n        }\n        if (!cssRect.height && rect.height) {\n          cssRect.height = rect.height;\n        }\n        // virtual item\n        return new GridItem(horizontal!, {\n          element,\n          cssRect,\n        });\n      }\n      return gridItem;\n    });\n\n    const containerManager = this.containerManager;\n    if (this.options.observeChildren) {\n      containerManager.unobserveChildren(removed.map((index) => prevList[index].element!));\n      containerManager.observeChildren(added.map((index) => list[index].element!));\n    }\n\n    const {\n      isRestore,\n      isResize,\n    } = e.state;\n\n    this.itemRenderer.renderItems(addedItems);\n\n    if (isRestore) {\n      this._onRenderComplete({\n        mounted: added.map((index) => list[index].orgItem),\n        updated: [],\n        isResize: false,\n        direction: this.defaultDirection,\n      });\n    }\n    if (!isRestore || isResize || e.isItemChanged) {\n      this.groupManager.renderItems();\n    }\n  }\n\n  private _onResize = (e: ResizeWatcherResizeEvent) => {\n    if (e.isResizeContainer) {\n      this._renderItems({ useResize: true }, true);\n    } else {\n      const updatedItems = getUpdatedItems(this.getVisibleItems(), e.childEntries) as InfiniteGridItem[];\n\n      if (updatedItems.length > 0) {\n        this.updateItems(updatedItems);\n      }\n    }\n  }\n\n  private _onRequestAppend = (e: OnRequestInsert): void => {\n    /**\n     * The event is fired when scrolling reaches the end or when data for a virtual group is required.\n     * @ko 스크롤이 끝에 도달하거나 virtual 그룹에 대한 데이터가 필요한 경우 이벤트가 발생한다.\n     * @event InfiniteGrid#requestAppend\n     * @param {InfiniteGrid.OnRequestAppend} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     */\n    this._onRequestInsert(DIRECTION.END, INFINITEGRID_EVENTS.REQUEST_APPEND, e);\n  }\n\n  private _onRequestPrepend = (e: OnInfiniteRequestPrepend): void => {\n    /**\n     * The event is fired when scrolling reaches the start or when data for a virtual group is required.\n     * @ko 스크롤이 끝에 도달하거나 virtual 그룹에 대한 데이터가 필요한 경우 이벤트가 발생한다.\n     * @event InfiniteGrid#requestPrepend\n     * @param {InfiniteGrid.OnRequestPrepend} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     */\n    this._onRequestInsert(DIRECTION.START, INFINITEGRID_EVENTS.REQUEST_PREPEND, e);\n  }\n\n  private _onRequestInsert(\n    direction: \"start\" | \"end\",\n    eventType: \"requestAppend\" | \"requestPrepend\",\n    e: OnInfiniteRequestAppend | OnInfiniteRequestPrepend,\n  ) {\n    if (this._waitType) {\n      this._checkStartLoading(this._waitType);\n      return;\n    }\n    this.trigger(new ComponentEvent(eventType, {\n      groupKey: e.key,\n      nextGroupKey: e.nextKey,\n      nextGroupKeys: e.nextKeys || [],\n      isVirtual: e.isVirtual,\n      wait: () => {\n        this.wait(direction);\n      },\n      ready: (hasNoData?: boolean) => {\n        this.ready(hasNoData);\n      },\n    }));\n  }\n\n  private _onContentError = ({ element, target, item, update }: OnContentError): void => {\n    /**\n     * The event is fired when scrolling reaches the start or when data for a virtual group is required.\n     * @ko 스크롤이 끝에 도달하거나 virtual 그룹에 대한 데이터가 필요한 경우 이벤트가 발생한다.\n     * @event InfiniteGrid#contentError\n     * @param {InfiniteGrid.OnContentError} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     */\n    this.trigger(new ComponentEvent(INFINITEGRID_EVENTS.CONTENT_ERROR, {\n      element,\n      target,\n      item: item as InfiniteGridItem,\n      update,\n      remove: () => {\n        this.removeByKey(item.key!);\n      },\n    }));\n  }\n\n  private _onRenderComplete = ({ isResize, mounted, updated, direction }: OnPickedRenderComplete): void => {\n    const infinite = this.infinite;\n    const scrollManager = this.scrollManager;\n    const scrollPos = scrollManager.getRelativeScrollPos()!;\n    const prevScrollSize = infinite.getScrollSize();\n    const prevContainerSize = infinite.getSize();\n    const prevVisibleArea = infinite.getVisibleArea(scrollPos, direction);\n    const isDirectionEnd = direction === DIRECTION.END;\n\n\n\n    this._syncInfinite();\n\n    if (prevVisibleArea) {\n      const prevPart = prevVisibleArea.part;\n      const prevItem = prevVisibleArea.item;\n      let nextPart!: InfiniteItemPart;\n      let nextItem!: InfiniteItem;\n\n      if (prevPart) {\n        nextPart = infinite.getItemPartByKey(prevPart.key);\n      }\n      if (prevItem) {\n        nextItem = infinite.getItemByKey(prevItem.key);\n      }\n\n      if (nextPart || nextItem) {\n        let prevPos = 0;\n        let nextPos = 0;\n\n        if (nextPart) {\n          nextPos = nextPart.pos + (isDirectionEnd ? 0 : nextPart.size);\n          prevPos = prevPart.pos + (isDirectionEnd ? 0 : prevPart.size);\n        } else {\n          const prevStartPos = Math.min(...prevItem.startOutline);\n          const prevEndPos = Math.max(...prevItem.endOutline);\n          const nextStartPos = Math.min(...nextItem.startOutline);\n          const nextEndPos = Math.max(...nextItem.endOutline);\n\n          nextPos = isDirectionEnd ? nextStartPos : nextEndPos;\n          prevPos = isDirectionEnd ? prevStartPos : prevEndPos;\n        }\n        let offset = nextPos - prevPos;\n\n        // If reversed, scroll size (case where container size is reduced)\n        if (offset < 0) {\n          const nextScrollSize = infinite.getScrollSize();\n          const nextContainerSize = infinite.getSize();\n          const endOffset = Math.max(scrollPos - Math.max(0, prevScrollSize - prevContainerSize), 0);\n          const nextScollPos\n            = Math.min(scrollPos, Math.max(0, nextScrollSize - nextContainerSize))\n            + endOffset;\n\n          // The scroll size is restored to the extent that it has been reduced.\n          offset += scrollPos - nextScollPos;\n        }\n\n        this.scrollManager.scrollBy(offset);\n      }\n    }\n\n    const completeMounted = (mounted as InfiniteGridItem[]).filter((item) => item.type !== ITEM_TYPE.LOADING);\n\n    /**\n     * This event is fired when the InfiniteGrid has completed rendering.\n     * @ko InfiniteGrid가 렌더링이 완료됐을 때 이벤트가 발생한다.\n     * @event InfiniteGrid#renderComplete\n     * @param {InfiniteGrid.OnRenderComplete} e - The object of data to be sent to an event <ko>이벤트에 전달되는 데이터 객체</ko>\n     */\n    this.trigger(new ComponentEvent(INFINITEGRID_EVENTS.RENDER_COMPLETE, {\n      isResize,\n      direction,\n      mounted: completeMounted,\n      updated: (updated as InfiniteGridItem[]).filter((item) => item.type !== ITEM_TYPE.LOADING),\n      startCursor: this.getStartCursor(),\n      endCursor: this.getEndCursor(),\n      items: this.getVisibleItems(true),\n      groups: this.getVisibleGroups(true),\n    }));\n\n    let isUpdate = this.groupManager.shouldRerenderItems();\n\n    if (completeMounted.length || updated.length) {\n      isUpdate ||= !!this.groupManager.endLoading();\n    }\n\n    if (isUpdate) {\n      this._update();\n    } else {\n      this._checkEndLoading();\n      this._scroll();\n    }\n  }\n  private _renderItems(options: RenderOptions = {}, isTrusted?: boolean) {\n    if (!isTrusted && options.useResize) {\n      this.containerManager.resize();\n    }\n    this._resizeScroll();\n    if (!this.getRenderingItems().length) {\n      const children = toArray(this.getContainerElement().children);\n      if (children.length > 0) {\n        // no items, but has children\n        this.groupManager.syncItems(convertInsertedItems(children));\n        this._syncInfinite();\n        this.setCursors(0, 0, true);\n        this._getRenderer().updated();\n      } else {\n        this.infinite.scroll(0);\n      }\n      return this;\n    }\n    if (!this.getVisibleGroups(true).length) {\n      this.setCursors(0, 0);\n    } else {\n      this.groupManager.renderItems(options);\n    }\n    return this;\n  }\n  private _checkStartLoading(direction: \"start\" | \"end\") {\n    const groupManager = this.groupManager;\n    const infinite = this.infinite;\n\n    if (\n      !groupManager.getLoadingType()\n      && infinite.isLoading(direction)\n      && groupManager.startLoading(direction)\n      && groupManager.hasLoadingItem()\n    ) {\n      this._update();\n    }\n  }\n  private _checkEndLoading() {\n    const groupManager = this.groupManager;\n    const loadingType = this.groupManager.getLoadingType();\n\n    if (\n      loadingType\n      && (!this._waitType || !this.infinite.isLoading(loadingType))\n      && groupManager.waitEndLoading()\n      && groupManager.hasLoadingItem()\n    ) {\n      this._update();\n    }\n  }\n}\n\ninterface InfiniteGrid extends Properties<typeof InfiniteGrid> { }\n\nexport default InfiniteGrid;\n","import { MasonryGrid, MasonryGridOptions } from \"@egjs/grid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridOptions } from \"../types\";\nimport { InfiniteGridGetterSetter } from \"../utils\";\n\n/**\n * @typedef\n * @extends InfiniteGridOptions\n * @extends Grid.MasonryGrid.MasonryGridOptions\n */\nexport interface MasonryInfiniteGridOptions extends MasonryGridOptions, InfiniteGridOptions {\n}\n\n/**\n * MasonryInfiniteGrid is a grid that stacks items with the same width as a stack of bricks. Adjust the width of all images to the same size, find the lowest height column, and insert a new item.\n * @ko MasonryInfiniteGrid는 벽돌을 쌓아 올린 모양처럼 동일한 너비를 가진 아이템을 쌓는 레이아웃이다. 모든 이미지의 너비를 동일한 크기로 조정하고, 가장 높이가 낮은 열을 찾아 새로운 이미지를 삽입한다. 따라서 배치된 아이템 사이에 빈 공간이 생기지는 않지만 배치된 레이아웃의 아래쪽은 울퉁불퉁해진다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {MasonryInfiniteGridOptions} options - The option object of the MasonryInfiniteGrid module <ko>MasonryInfiniteGrid 모듈의 옵션 객체</ko>\n */\n@InfiniteGridGetterSetter\nexport class MasonryInfiniteGrid extends InfiniteGrid<MasonryInfiniteGridOptions> {\n  public static propertyTypes = {\n    ...InfiniteGrid.propertyTypes,\n    ...MasonryGrid.propertyTypes,\n  };\n  public static defaultOptions: Required<MasonryInfiniteGridOptions> = {\n    ...InfiniteGrid.defaultOptions,\n    ...MasonryGrid.defaultOptions,\n    gridConstructor: MasonryGrid,\n    appliedItemChecker: (item, grid) => {\n      const column = parseFloat(item.attributes.column) || 0;\n\n      return column >= grid.outlineLength;\n    },\n  } as const;\n}\n","import { JustifiedGrid, JustifiedGridOptions } from \"@egjs/grid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridOptions } from \"../types\";\nimport { InfiniteGridGetterSetter } from \"../utils\";\n\n/**\n * @typedef\n * @extends InfiniteGridOptions\n * @extends Grid.JustifiedGrid.JustifiedGridOptions\n */\nexport interface JustifiedInfiniteGridOptions extends JustifiedGridOptions, InfiniteGridOptions {\n}\n\n/**\n * 'justified' is a printing term with the meaning that 'it fits in one row wide'. JustifiedInfiniteGrid is a grid that the item is filled up on the basis of a line given a size.\n * If 'data-grid-inline-offset' or 'data-grid-content-offset' are set for item element, the ratio is maintained except for the offset value.\n * If 'data-grid-maintained-target' is set for an element whose ratio is to be maintained, the item is rendered while maintaining the ratio of the element.\n * @ko 'justified'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. JustifiedInfiniteGrid는 용어의 의미대로 너비가 주어진 사이즈를 기준으로 아이템가 가득 차도록 배치하는 Grid다.\n * 아이템 엘리먼트에 'data-grid-inline-offset' 또는 'data-grid-content-offset'를 설정하면 offset 값을 제외하고 비율을 유지한다.\n * 비율을 유지하고 싶은 엘리먼트에 'data-grid-maintained-target'을 설정한다면 해당 엘리먼트의 비율을 유지하면서 아이템이 렌더링이 된다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {JustifiedInfiniteGridOptions} options - The option object of the JustifiedInfiniteGrid module <ko>JustifiedInfiniteGrid 모듈의 옵션 객체</ko>\n */\n@InfiniteGridGetterSetter\nexport class JustifiedInfiniteGrid extends InfiniteGrid<JustifiedInfiniteGridOptions> {\n  public static propertyTypes = {\n    ...InfiniteGrid.propertyTypes,\n    ...JustifiedGrid.propertyTypes,\n  };\n  public static defaultOptions: Required<JustifiedInfiniteGridOptions> = {\n    ...InfiniteGrid.defaultOptions,\n    ...JustifiedGrid.defaultOptions,\n    gridConstructor: JustifiedGrid,\n  } as const;\n}\n","import { FrameGrid, FrameGridOptions } from \"@egjs/grid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridOptions } from \"../types\";\nimport { InfiniteGridGetterSetter } from \"../utils\";\n\n/**\n * @typedef\n * @extends InfiniteGridOptions\n * @extends Grid.FrameGrid.FrameGridOptions\n */\nexport interface FrameInfiniteGridOptions extends FrameGridOptions, InfiniteGridOptions {\n}\n\n/**\n * 'Frame' is a printing term with the meaning that 'it fits in one row wide'. FrameInfiniteGrid is a grid that the item is filled up on the basis of a line given a size.\n * @ko 'Frame'는 '1행의 너비에 맞게 꼭 들어찬'이라는 의미를 가진 인쇄 용어다. FrameInfiniteGrid는 용어의 의미대로 너비가 주어진 사이즈를 기준으로 아이템이 가득 차도록 배치하는 Grid다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {FrameInfiniteGridOptions} options - The option object of the FrameInfiniteGrid module <ko>FrameGrid 모듈의 옵션 객체</ko>\n */\n@InfiniteGridGetterSetter\nexport class FrameInfiniteGrid extends InfiniteGrid<FrameInfiniteGridOptions> {\n  public static propertyTypes = {\n    ...InfiniteGrid.propertyTypes,\n    ...FrameGrid.propertyTypes,\n  };\n  public static defaultOptions: Required<FrameInfiniteGridOptions> = {\n    ...InfiniteGrid.defaultOptions,\n    ...FrameGrid.defaultOptions,\n    gridConstructor: FrameGrid,\n  } as const;\n}\n","import { PackingGrid, PackingGridOptions } from \"@egjs/grid\";\nimport InfiniteGrid from \"../InfiniteGrid\";\nimport { InfiniteGridOptions } from \"../types\";\nimport { InfiniteGridGetterSetter } from \"../utils\";\n\n/**\n * @typedef\n * @extends InfiniteGridOptions\n * @extends Grid.PackingGrid.PackingGridOptions\n */\nexport interface PackingInfiniteGridOptions extends PackingGridOptions, InfiniteGridOptions {\n}\n\n/**\n * The PackingInfiniteGrid is a grid that shows the important items bigger without sacrificing the weight of the items.\n * Rows and columns are separated so that items are dynamically placed within the horizontal and vertical space rather than arranged in an orderly fashion.\n * If `sizeWeight` is higher than `ratioWeight`, the size of items is preserved as much as possible.\n * Conversely, if `ratioWeight` is higher than `sizeWeight`, the ratio of items is preserved as much as possible.\n * @ko PackingInfiniteGrid는 아이템의 본래 크기에 따른 비중을 해치지 않으면서 중요한 카드는 더 크게 보여 주는 레이아웃이다.\n * 행과 열이 구분돼 아이템을 정돈되게 배치하는 대신 가로세로 일정 공간 내에서 동적으로 아이템을 배치한다.\n * `sizeWeight`가 `ratioWeight`보다 높으면 아이템들의 size가 최대한 보존이 된다.\n * 반대로 `ratioWeight`가 `sizeWeight`보다 높으면 아이템들의 비율이 최대한 보존이 된다.\n * @param {HTMLElement | string} container - A base element for a module <ko>모듈을 적용할 기준 엘리먼트</ko>\n * @param {PackingInfiniteGridOptions} options - The option object of the PackingInfiniteGrid module <ko>PackingInfiniteGrid 모듈의 옵션 객체</ko>\n */\n@InfiniteGridGetterSetter\nexport class PackingInfiniteGrid extends InfiniteGrid<PackingInfiniteGridOptions> {\n  public static propertyTypes = {\n    ...InfiniteGrid.propertyTypes,\n    ...PackingGrid.propertyTypes,\n  };\n  public static defaultOptions: Required<PackingInfiniteGridOptions> = {\n    ...InfiniteGrid.defaultOptions,\n    ...PackingGrid.defaultOptions,\n    gridConstructor: PackingGrid,\n  };\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}