{"ast":null,"code":"/*\nCopyright (c) NAVER Corp.\nname: @egjs/react-infinitegrid\nlicense: MIT\nauthor: NAVER Corp.\nrepository: https://github.com/naver/egjs-infinitegrid\nversion: 4.12.0\n*/\nimport { createElement, Children, cloneElement, createRef, Component } from 'react';\nimport VanillaInfiniteGrid, { Renderer, mountRenderingItems, getRenderingItems, ITEM_TYPE, withInfiniteGridMethods, MasonryInfiniteGrid as MasonryInfiniteGrid$1, JustifiedInfiniteGrid as JustifiedInfiniteGrid$1, FrameInfiniteGrid as FrameInfiniteGrid$1, PackingInfiniteGrid as PackingInfiniteGrid$1 } from '@egjs/infinitegrid';\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol */\n\nvar extendStatics = function (d, b) {\n  extendStatics = Object.setPrototypeOf || {\n    __proto__: []\n  } instanceof Array && function (d, b) {\n    d.__proto__ = b;\n  } || function (d, b) {\n    for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n  };\n  return extendStatics(d, b);\n};\nfunction __extends(d, b) {\n  if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n  extendStatics(d, b);\n  function __() {\n    this.constructor = d;\n  }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\nvar __assign = function () {\n  __assign = Object.assign || function __assign(t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n}\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length,\n    r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n    d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\nvar _SuppressedError = typeof SuppressedError === \"function\" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = \"SuppressedError\", e.error = error, e.suppressed = suppressed, e;\n};\nvar REACT_INFINITEGRID_EVENT_MAP = {\n  \"onContentError\": \"contentError\",\n  \"onRenderComplete\": \"renderComplete\",\n  \"onRequestAppend\": \"requestAppend\",\n  \"onRequestPrepend\": \"requestPrepend\",\n  \"onChangeScroll\": \"changeScroll\"\n};\nvar REACT_INFINITEGRID_EVENTS = [];\nfor (var name in REACT_INFINITEGRID_EVENT_MAP) {\n  REACT_INFINITEGRID_EVENTS.push(name);\n}\nvar REACT_INFINITEGRID_PROPS = __spreadArray([\"tag\", \"placeholder\", \"status\", \"useFirstRender\", \"loading\", \"itemBy\", \"groupBy\", \"infoBy\"], REACT_INFINITEGRID_EVENTS, true);\nfunction isFunction(val) {\n  return typeof val === \"function\";\n}\nvar InfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(InfiniteGrid, _super);\n  function InfiniteGrid() {\n    var _this = _super !== null && _super.apply(this, arguments) || this;\n    _this._wrapperRef = createRef();\n    _this._containerRef = createRef();\n    return _this;\n  }\n  var __proto = InfiniteGrid.prototype;\n  __proto.render = function () {\n    var attributes = {};\n    var props = this.props;\n    var GridClass = this.constructor.GridClass;\n    var defaultOptions = GridClass.defaultOptions;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var Tag = props.tag || \"div\";\n    for (var name in props) {\n      if (name in defaultOptions || REACT_INFINITEGRID_PROPS.indexOf(name) > -1) {\n        continue;\n      }\n      attributes[name] = props[name];\n    }\n    return createElement(Tag, __assign({\n      ref: this._wrapperRef\n    }, attributes), this._renderContainer());\n  };\n  __proto.componentDidMount = function () {\n    var _this = this;\n    var GridClass = this.constructor.GridClass;\n    var defaultOptions = GridClass.defaultOptions;\n    var options = {};\n    var props = this.props;\n    var containerElement = this._containerRef.current;\n    for (var name in defaultOptions) {\n      if (name in props) {\n        options[name] = props[name];\n      }\n    }\n    if (containerElement) {\n      options.container = containerElement;\n    }\n    this._renderer = new Renderer();\n    options.renderer = this._renderer;\n    var grid = new GridClass(this._wrapperRef.current, options);\n    var _loop_1 = function (eventName) {\n      var nativeEventName = REACT_INFINITEGRID_EVENT_MAP[eventName];\n      grid.on(nativeEventName, function (e) {\n        var callback = _this.props[eventName];\n        callback && callback(e);\n      });\n    };\n    for (var eventName in REACT_INFINITEGRID_EVENT_MAP) {\n      _loop_1(eventName);\n    }\n    this._grid = grid;\n    this._renderer.on(\"update\", function () {\n      _this.setState({});\n    });\n    mountRenderingItems(this._getItemInfos(), {\n      grid: grid,\n      useFirstRender: props.useFirstRender,\n      useLoading: props.loading,\n      usePlaceholder: props.placeholder,\n      horizontal: props.horizontal,\n      status: props.status\n    });\n    this._renderer.updated();\n  };\n  __proto.componentDidUpdate = function () {\n    var GridClass = this.constructor.GridClass;\n    var propertyTypes = GridClass.propertyTypes;\n    var props = this.props;\n    var grid = this._grid;\n    for (var name in propertyTypes) {\n      if (name in props) {\n        grid[name] = props[name];\n      }\n    }\n    this._renderer.updated();\n  };\n  __proto.componentWillUnmount = function () {\n    this._grid.destroy();\n  };\n  __proto._getItemInfos = function () {\n    var props = this.props;\n    var children = Children.toArray(props.children);\n    var attributePrefix = props.attributePrefix || VanillaInfiniteGrid.defaultOptions.attributePrefix;\n    var itemBy = props.itemBy || function (item) {\n      return item.key;\n    };\n    var groupBy = props.groupBy || function (item) {\n      return item.props[\"\".concat(attributePrefix, \"groupkey\")];\n    };\n    var infoBy = props.infoBy || function () {\n      return {};\n    };\n    return children.map(function (child, i) {\n      var _a = infoBy(child, i) || {},\n        data = _a.data,\n        rest = __rest(_a, [\"data\"]);\n      return __assign(__assign({\n        groupKey: groupBy(child, i),\n        key: itemBy(child, i)\n      }, rest), {\n        data: __assign(__assign({}, data), {\n          jsx: child\n        })\n      });\n    });\n  };\n  __proto._renderContainer = function () {\n    var props = this.props;\n    var visibleChildren = this._getVisibleChildren();\n    var container = props.container;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    var ContainerTag = props.containerTag || \"div\";\n    if (container === true) {\n      return createElement(ContainerTag, {\n        ref: this._containerRef\n      }, visibleChildren);\n    } else {\n      return visibleChildren;\n    }\n  };\n  __proto._getVisibleChildren = function () {\n    var props = this.props;\n    var placeholder = props.placeholder;\n    var loading = props.loading;\n    var visibleItems = getRenderingItems(this._getItemInfos(), {\n      grid: this._grid,\n      status: props.status,\n      horizontal: props.horizontal,\n      useFirstRender: props.useFirstRender,\n      useLoading: props.loading,\n      usePlaceholder: props.placeholder\n    });\n    return visibleItems.map(function (item) {\n      if (item.type === ITEM_TYPE.VIRTUAL) {\n        return cloneElement(isFunction(placeholder) ? placeholder(item) : placeholder, {\n          key: item.key\n        });\n      } else if (item.type === ITEM_TYPE.LOADING) {\n        return cloneElement(isFunction(loading) ? loading(item) : loading, {\n          key: item.key\n        });\n      } else {\n        return item.data.jsx;\n      }\n    });\n  };\n  __decorate([withInfiniteGridMethods], InfiniteGrid.prototype, \"_grid\", void 0);\n  return InfiniteGrid;\n}(Component);\nvar MasonryInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(MasonryInfiniteGrid, _super);\n  function MasonryInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  MasonryInfiniteGrid.GridClass = MasonryInfiniteGrid$1;\n  return MasonryInfiniteGrid;\n}(InfiniteGrid);\nvar JustifiedInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(JustifiedInfiniteGrid, _super);\n  function JustifiedInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  JustifiedInfiniteGrid.GridClass = JustifiedInfiniteGrid$1;\n  return JustifiedInfiniteGrid;\n}(InfiniteGrid);\nvar FrameInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(FrameInfiniteGrid, _super);\n  function FrameInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  FrameInfiniteGrid.GridClass = FrameInfiniteGrid$1;\n  return FrameInfiniteGrid;\n}(InfiniteGrid);\nvar PackingInfiniteGrid = /*#__PURE__*/function (_super) {\n  __extends(PackingInfiniteGrid, _super);\n  function PackingInfiniteGrid() {\n    return _super !== null && _super.apply(this, arguments) || this;\n  }\n  PackingInfiniteGrid.GridClass = PackingInfiniteGrid$1;\n  return PackingInfiniteGrid;\n}(InfiniteGrid);\nexport { FrameInfiniteGrid, InfiniteGrid, JustifiedInfiniteGrid, MasonryInfiniteGrid, PackingInfiniteGrid };","map":{"version":3,"names":["REACT_INFINITEGRID_EVENT_MAP","REACT_INFINITEGRID_EVENTS","name","push","REACT_INFINITEGRID_PROPS","__spreadArray","isFunction","val","__extends","InfiniteGrid","_super","_this","apply","arguments","_wrapperRef","createRef","_containerRef","__proto","prototype","render","attributes","props","GridClass","constructor","defaultOptions","Tag","tag","indexOf","createElement","__assign","ref","_renderContainer","componentDidMount","options","containerElement","current","container","_renderer","Renderer","renderer","grid","eventName","nativeEventName","on","e","callback","_grid","setState","mountRenderingItems","_getItemInfos","useFirstRender","useLoading","loading","usePlaceholder","placeholder","horizontal","status","updated","componentDidUpdate","propertyTypes","componentWillUnmount","destroy","children","Children","toArray","attributePrefix","VanillaInfiniteGrid","itemBy","item","key","groupBy","concat","infoBy","map","child","i","_a","data","rest","__rest","groupKey","jsx","visibleChildren","_getVisibleChildren","ContainerTag","containerTag","visibleItems","getRenderingItems","type","ITEM_TYPE","VIRTUAL","cloneElement","LOADING","__decorate","withInfiniteGridMethods","Component","MasonryInfiniteGrid","MasonryInfiniteGrid$1","JustifiedInfiniteGrid","JustifiedInfiniteGrid$1","FrameInfiniteGrid","FrameInfiniteGrid$1","PackingInfiniteGrid","PackingInfiniteGrid$1"],"sources":["/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/consts.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/utils.ts","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/InfiniteGrid.tsx","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/grids/MasonryInfiniteGrid.tsx","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/grids/JustifiedInfiniteGrid.tsx","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/grids/FrameInfiniteGrid.tsx","/Users/jasonglaspey/Coding/Lost Valley - Image Management/web-app/client/node_modules/@egjs/react-infinitegrid/src/grids/PackingInfiniteGrid.tsx"],"sourcesContent":["\nexport const REACT_INFINITEGRID_EVENT_MAP = {\n  \"onContentError\": \"contentError\",\n  \"onRenderComplete\": \"renderComplete\",\n  \"onRequestAppend\": \"requestAppend\",\n  \"onRequestPrepend\": \"requestPrepend\",\n  \"onChangeScroll\": \"changeScroll\",\n} as const;\n\nexport const REACT_INFINITEGRID_EVENTS: string[] = [];\n\nfor (const name in REACT_INFINITEGRID_EVENT_MAP) {\n  REACT_INFINITEGRID_EVENTS.push(name);\n}\n\nexport const REACT_INFINITEGRID_PROPS = [\n  \"tag\",\n  \"placeholder\",\n  \"status\",\n  \"useFirstRender\",\n  \"loading\",\n  \"itemBy\",\n  \"groupBy\",\n  \"infoBy\",\n  ...REACT_INFINITEGRID_EVENTS,\n];\n","export function isFunction(val: any): val is Function {\n  return typeof val === \"function\";\n}\n","/**\n * egjs-infinitegrid\n * Copyright (c) 2021-present NAVER Corp.\n * MIT license\n */\nimport * as React from \"react\";\nimport VanillaInfiniteGrid, {\n  InfiniteGridOptions, InfiniteGridFunction,\n  Renderer,\n  InfiniteGridItemInfo,\n  ITEM_TYPE,\n  InfiniteGridMethods,\n  withInfiniteGridMethods,\n  getRenderingItems,\n  mountRenderingItems,\n} from \"@egjs/infinitegrid\";\nimport { ReactInfiniteGridProps } from \"./types\";\nimport { REACT_INFINITEGRID_PROPS, REACT_INFINITEGRID_EVENT_MAP } from \"./consts\";\nimport { isFunction } from \"./utils\";\n\nexport abstract class InfiniteGrid<T extends InfiniteGridOptions>\n  extends React.Component<T & ReactInfiniteGridProps & { [key: string]: any }> {\n  public static GridClass: InfiniteGridFunction;\n  @withInfiniteGridMethods\n  private _grid!: VanillaInfiniteGrid;\n  private _wrapperRef = React.createRef<HTMLDivElement>();\n  private _containerRef = React.createRef<HTMLDivElement>();\n  private _renderer!: Renderer;\n\n  public render() {\n    const attributes: { [key: string]: any } = {};\n    const props = this.props;\n    const GridClass = (this.constructor as typeof InfiniteGrid).GridClass;\n    const defaultOptions = GridClass.defaultOptions;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const Tag = props.tag as any || \"div\";\n\n    for (const name in props) {\n      if (name in defaultOptions || REACT_INFINITEGRID_PROPS.indexOf(name as any) > -1) {\n        continue;\n      }\n      attributes[name] = props[name];\n    }\n\n    return <Tag ref={this._wrapperRef} {...attributes}>\n      {this._renderContainer()}\n    </Tag>;\n  }\n  public componentDidMount() {\n    const GridClass = (this.constructor as typeof InfiniteGrid).GridClass;\n    const defaultOptions = GridClass.defaultOptions;\n    const options: Partial<InfiniteGridOptions> = {};\n    const props = this.props;\n    const containerElement = this._containerRef.current;\n\n    for (const name in defaultOptions) {\n      if (name in props) {\n        (options as any)[name] = (props as any)[name];\n      }\n    }\n    if (containerElement) {\n      options.container = containerElement;\n    }\n    this._renderer = new Renderer();\n    options.renderer = this._renderer;\n    const grid = new GridClass(this._wrapperRef.current!, options);\n\n    for (const eventName in REACT_INFINITEGRID_EVENT_MAP) {\n      const nativeEventName = (REACT_INFINITEGRID_EVENT_MAP as any)[eventName];\n\n      grid.on(nativeEventName, (e: any) => {\n        const callback = this.props[eventName];\n\n        callback && callback(e);\n      });\n    }\n\n    this._grid = grid;\n    this._renderer.on(\"update\", () => {\n      this.setState({});\n    });\n\n    mountRenderingItems(this._getItemInfos(), {\n      grid,\n      useFirstRender: props.useFirstRender,\n      useLoading: props.loading,\n      usePlaceholder: props.placeholder,\n      horizontal: props.horizontal,\n      status: props.status,\n    });\n    this._renderer.updated();\n  }\n\n  public componentDidUpdate() {\n    const GridClass = (this.constructor as typeof InfiniteGrid).GridClass;\n    const propertyTypes = GridClass.propertyTypes;\n    const props = this.props;\n    const grid = this._grid;\n\n    for (const name in propertyTypes) {\n      if (name in props) {\n        (grid as any)[name] = (props as any)[name];\n      }\n    }\n    this._renderer.updated();\n  }\n\n  public componentWillUnmount() {\n    this._grid.destroy();\n  }\n\n  private _getItemInfos(): InfiniteGridItemInfo[] {\n    const props = this.props;\n    const children = React.Children.toArray(props.children) as React.ReactElement[];\n    const attributePrefix = props.attributePrefix || VanillaInfiniteGrid.defaultOptions.attributePrefix;\n    const itemBy = props.itemBy || ((item: React.ReactElement) => item.key);\n    const groupBy = props.groupBy || ((item: React.ReactElement) => item.props[`${attributePrefix}groupkey`]);\n    const infoBy = props.infoBy || (() => ({}));\n\n    \n    return children.map((child, i) => {\n      const {\n        data,\n        ...rest\n      } = infoBy(child, i) || {};\n\n      \n      return {\n        groupKey: groupBy(child, i),\n        key: itemBy(child, i),\n        ...rest,\n        data: {\n          ...data,\n          jsx: child,\n        },\n      };\n    });\n  }\n  private _renderContainer() {\n    const props = this.props;\n    const visibleChildren = this._getVisibleChildren();\n    const container = props.container;\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    const ContainerTag = props.containerTag as any || \"div\";\n\n    if (container === true) {\n      return <ContainerTag ref={this._containerRef}>\n        {visibleChildren}\n      </ContainerTag>;\n    } else {\n      return visibleChildren;\n    }\n  }\n  private _getVisibleChildren() {\n    const props = this.props;\n    const placeholder = props.placeholder;\n    const loading = props.loading;\n    const visibleItems = getRenderingItems(this._getItemInfos(), {\n      grid: this._grid,\n      status: props.status,\n      horizontal: props.horizontal,\n      useFirstRender: props.useFirstRender,\n      useLoading: props.loading,\n      usePlaceholder: props.placeholder,\n    });\n\n    return visibleItems.map((item) => {\n      if (item.type === ITEM_TYPE.VIRTUAL) {\n        return React.cloneElement(isFunction(placeholder) ? placeholder(item) : placeholder, { key: item.key });\n      } else if (item.type === ITEM_TYPE.LOADING) {\n        return React.cloneElement(isFunction(loading) ? loading(item) : loading, { key: item.key });\n      } else {\n        return item.data.jsx;\n      }\n    });\n  }\n}\nexport interface InfiniteGrid<T extends InfiniteGridOptions> extends InfiniteGridMethods<InfiniteGrid<T>> { }\n","import {\n  MasonryInfiniteGrid as VanillaMasonryInfiniteGrid,\n  MasonryInfiniteGridOptions,\n} from \"@egjs/infinitegrid\";\nimport { InfiniteGrid } from \"../InfiniteGrid\";\n\nexport class MasonryInfiniteGrid extends InfiniteGrid<MasonryInfiniteGridOptions> {\n  public static GridClass = VanillaMasonryInfiniteGrid;\n}\n","import {\n  JustifiedInfiniteGrid as VanillaJustifiedInfiniteGrid,\n  JustifiedInfiniteGridOptions,\n} from \"@egjs/infinitegrid\";\nimport { InfiniteGrid } from \"../InfiniteGrid\";\n\nexport class JustifiedInfiniteGrid extends InfiniteGrid<JustifiedInfiniteGridOptions> {\n  public static GridClass = VanillaJustifiedInfiniteGrid;\n}\n","import {\n  FrameInfiniteGrid as VanillaFrameInfiniteGrid,\n  FrameInfiniteGridOptions,\n} from \"@egjs/infinitegrid\";\nimport { InfiniteGrid } from \"../InfiniteGrid\";\n\nexport class FrameInfiniteGrid extends InfiniteGrid<FrameInfiniteGridOptions> {\n  public static GridClass = VanillaFrameInfiniteGrid;\n}\n","import {\n  PackingInfiniteGrid as VanillaPackingInfiniteGrid,\n  PackingInfiniteGridOptions,\n} from \"@egjs/infinitegrid\";\nimport { InfiniteGrid } from \"../InfiniteGrid\";\n\nexport class PackingInfiniteGrid extends InfiniteGrid<PackingInfiniteGridOptions> {\n  public static GridClass = VanillaPackingInfiniteGrid;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}